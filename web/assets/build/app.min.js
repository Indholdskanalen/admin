/**
 * @name Aroskanalen
 * @version v3.3.0
 * @link https://github.com/aroskanalen/admin
 */
/**
 * @file
 * Contains the ikApp module.
 */

/**
 * ikApp - Main entry point for the app.
 *
 * Register modules here.
 */
angular.module('ikApp', [
    'ngRoute',
    'ngAnimate',
    'angularFileUpload',
    'colorpicker.module',
    'datetimePicker',
    'ngLocale',
    'taiPlaceholder',
    'ngModal',
    'angular.css.injector',

    'itkLog',

    'itkControlPanel',
    'itkScreenTemplatePickerWidget',
    'itkTextWidget',
    'itkTextAreaWidget',
    'itkNumberWidget',
    'itkChannelPickerWidget',
    'itkSharedChannelPickerWidget',
    'itkChannelRemoverWidget',
    'itkRegionPreviewWidget',
    'itkDateComponent'
  ],
  function () {
  }
)
  .config(["$sceDelegateProvider", function ($sceDelegateProvider) {
    'use strict';

    // The administration interface and the client code do not run on the same
    // domain/sub-domain hence we need to whitelist the domains to load slide
    // templates and CSS form the administration domain.
    $sceDelegateProvider.resourceUrlWhitelist([
      // Allow same origin resource loads.
      'self',
      // Allow loading from outer templates domain.
      '**'
    ]);
  }])
  .config(["$provide", function ($provide) {
    "use strict";

    $provide.decorator("$exceptionHandler", ['$delegate', '$injector',
      function ($delegate, $injector) {
        return function (exception, cause) {
          $delegate(exception, cause);

          $injector.get('itkLog').error(exception, cause);
        };
      }
    ]);
  }]);

/**
 * @file
 * Contains the routing for the ikApp module.
 */

/**
 * Routing.
 */
angular.module('ikApp').config(["$routeProvider", function ($routeProvider) {
  'use strict';

  $routeProvider
    // Frontpage, set to channel overview.
    .when('/', {
      redirectTo: '/channel-overview'
    })

    .when('/admin-sharing', {
      controller: 'AdminSharingController',
      templateUrl: 'app/pages/adminSharing/admin-sharing.html?' + window.config.version
    })
    .when('/admin-templates', {
      controller: 'AdminTemplatesController',
      templateUrl: 'app/pages/adminTemplates/admin-templates.html?' + window.config.version
    })

    // Overviews
    .when('/channel-overview', {
      controller: 'ChannelOverviewController',
      templateUrl: 'app/pages/channelOverview/channel-overview.html?' + window.config.version
    })
    .when('/slide-overview', {
      controller: 'SlideOverviewController',
      templateUrl: 'app/pages/slideOverview/slide-overview.html?' + window.config.version
    })
    .when('/screen-overview', {
      controller: 'ScreenOverviewController',
      templateUrl: 'app/pages/screenOverview/screen-overview.html?' + window.config.version
    })
    .when('/media-overview', {
      controller: 'MediaOverviewController',
      templateUrl: 'app/pages/mediaOverview/media-overview.html?' + window.config.version
    })
    .when('/shared-channel-overview', {
      controller: 'SharedChannelOverviewController',
      templateUrl: 'app/pages/sharedChannelOverview/shared-channel-overview.html?' + window.config.version
    })

    // Screen
    .when('/screen', {
      controller: 'ScreenController',
      templateUrl: 'app/pages/screen/screen.html?' + window.config.version
    })
    .when('/screen/:id', {
      controller: 'ScreenController',
      templateUrl: 'app/pages/screen/screen.html?' + window.config.version
    })

    // Slide
    .when('/slide', {
      controller: 'SlideController',
      templateUrl: 'app/pages/slide/slide.html?' + window.config.version
    })
    .when('/slide/:id', {
      controller: 'SlideController',
      templateUrl: 'app/pages/slide/slide.html?' + window.config.version
    })

    // Channel
    .when('/shared-channel/:id/:index', {
      controller: 'SharedChannelController',
      templateUrl: 'app/pages/sharedChannel/shared-channel.html?' + window.config.version
    })
    .when('/channel', {
      controller: 'ChannelController',
      templateUrl: 'app/pages/channel/channel.html?' + window.config.version
    })
    .when('/channel/:id', {
      controller: 'ChannelController',
      templateUrl: 'app/pages/channel/channel.html?' + window.config.version
    })

    // Media
    .when('/media/upload', {
      controller: 'MediaUploadController',
      templateUrl: 'app/pages/mediaUpload/media-upload.html?' + window.config.version
    })
    .when('/media/:id', {
      controller: 'MediaEditController',
      templateUrl: 'app/pages/mediaEdit/media-edit.html?' + window.config.version
    })

    .otherwise({redirectTo: '/'});
}]);

/**
 * @file
 * Contains the admin sharing controller.
 */

/**
 * Admin sharing controller.
 */
angular.module('ikApp').controller('AdminSharingController', ['$scope', 'sharedChannelFactory', 'itkLog',
  function ($scope, sharedChannelFactory, itkLog) {
    'use strict';

    $scope.saving = false;

    $scope.availableIndexes = [];
    sharedChannelFactory.getAvailableIndexes().then(
      function success(data) {
        data.forEach(function (element) {
          // Only include shared indexes.
          if (element.tag === 'shared') {
            $scope.availableIndexes.push(element);
          }
        });
      },
      function error(reason) {
        itkLog.error('Hentning af tilgængelige delingsindeks fejlede.', reason);
      }
    );
    $scope.chosenIndexes = [];
    sharedChannelFactory.getSharingIndexes().then(
      function success(data) {
        $scope.chosenIndexes = data;
      },
      function error(reason) {
        itkLog.error('Hentning af valgte delingsindeks fejlede.', reason);
      }
    );

    $scope.save = function () {
      $scope.saving = true;
      sharedChannelFactory.saveSharingIndexes($scope.chosenIndexes).then(
        function success() {
          itkLog.info('Delingsindeks gemt', 3000);
          $scope.saving = false;
        },
        function error(reason) {
          itkLog.error('Delingsindeks blev ikke gemt', reason);
          $scope.saving = false;
        }
      );
    }
  }
]);
/**
 * @file
 * Contains the admin sharing controller.
 */

/**
 * Admin sharing controller.
 */
angular.module('ikApp').controller('AdminTemplatesController', ['$scope', 'templateFactory', 'itkLog',
  function ($scope, templateFactory, itkLog) {
    'use strict';

    $scope.saving = false;
    $scope.screenTemplates = [];
    $scope.slideTemplates = [];
    $scope.enabledScreenTemplates = [];
    $scope.enabledSlideTemplates = [];

    templateFactory.getAllScreenTemplates().then(
      function success(data) {
        $scope.screenTemplates = data;

        var arr = [];
        for (var i = 0; i < data.length; i++) {
          if (data[i].enabled) {
            arr.push(data[i]);
          }
        }
        $scope.enabledScreenTemplates = arr;
      },
      function error(reason) {
        itkLog.error('Hentning af tilgængelige templates fejlede.', reason);
      }
    );
    templateFactory.getAllSlideTemplates().then(
      function success(data) {
        $scope.slideTemplates = data;

        var arr = [];
        for (var i = 0; i < data.length; i++) {
          if (data[i].enabled) {
            arr.push(data[i]);
          }
        }
        $scope.enabledSlideTemplates = arr;
      },
      function error(reason) {
        itkLog.error('Hentning af tilgængelige templates fejlede.', reason);
      }
    );

    $scope.save = function () {
      $scope.saving = true;
      templateFactory.saveEnabledTemplates($scope.enabledScreenTemplates, $scope.enabledSlideTemplates).then(
        function success() {
          itkLog.info('Template valg gemt', 3000);
          $scope.saving = false;
        },
        function error(reason) {
          itkLog.error('Template valg blev ikke gemt', reason);
          $scope.saving = false;
        }
      );
    }
  }
]);
/**
 * @file
 * Channel creation controllers.
 */

/**
 * Channel controller. Controls the channel creation process.
 */
angular.module('ikApp').controller('ChannelController', ['$scope', '$location', '$routeParams', '$timeout', 'channelFactory', 'slideFactory', 'itkLog',
  function ($scope, $location, $routeParams, $timeout, channelFactory, slideFactory, itkLog) {
    'use strict';

    $scope.steps = 3;
    $scope.slides = [];
    $scope.channel = {};

    // Days, for use with schedule day checklist
    // Follows the javascript  Date.getDay()  numbers for days.
    // http://www.w3schools.com/jsref/jsref_getday.asp
    $scope.days = [
      {"id": 1, "name": "Mandag"},
      {"id": 2, "name": "Tirsdag"},
      {"id": 3, "name": "Onsdag"},
      {"id": 4, "name": "Torsdag"},
      {"id": 5, "name": "Fredag"},
      {"id": 6, "name": "Lørdag"},
      {"id": 0, "name": "Søndag"}
    ];

    // Get all slides.
    slideFactory.getSlides().then(
      function (data) {
        $scope.slides = data;
      },
      function error(reason) {
        itkLog.error("Hentning af slides fejlede", reason);
      }
    );

    // Setup the editor.
    $scope.editor = {
      slideOverviewEditor: false,
      toggleSlideOverviewEditor: function () {
        $('html').toggleClass('is-locked');
        $scope.editor.slideOverviewEditor = !$scope.editor.slideOverviewEditor;
      }
    };

    // Register event listener for clickSlide.
    $scope.$on('slideOverview.clickSlide', function (event, slide) {
      $scope.toggleSlide(slide);
    });

    /**
     * Loads a given step.
     */
    function loadStep(step) {
      $scope.step = step;
      $scope.templatePath = '/app/pages/channel/channel-step' + $scope.step + '.html';
    }

    /**
     * Constructor.
     * Handles different settings of route parameters.
     */
    function init() {
      if (!$routeParams.id) {
        // If the ID is not set, get an empty channel.
        $scope.channel = channelFactory.emptyChannel();
        loadStep(1);
      } else {
        if ($routeParams.id == null || $routeParams.id == undefined || $routeParams.id == '') {
          $location.path('/channel');
        }
        else {
          channelFactory.getEditChannel($routeParams.id).then(
            function (data) {
              $scope.channel = data;
              $scope.channel.status = 'edit-channel';

              if ($scope.channel === {}) {
                $location.path('/channel');
              }

              // Go to add slides page.
              loadStep(2);
            },
            function error(reason) {
              $location.path('/channel-overview');
              itkLog.error("Hentning af valgt kanal med id:" + $routeParams.id + " fejlede", reason);
            }
          );
        }
      }
    }

    init();

    /**
     * Submit a step in the installation process.
     */
    $scope.submitStep = function () {
      if ($scope.step == $scope.steps) {
        $scope.disableSubmitButton = true;

        channelFactory.saveChannel().then(
          function success() {
            itkLog.info("Kanal gemt.", 3000);
            $timeout(function () {
              $location.path('/channel-overview');
            }, 1000);
          },
          function error(reason) {
            itkLog.error("Gem af kanal fejlede.", reason);
            $scope.disableSubmitButton = false;
          }
        );
      } else {
        loadStep($scope.step + 1);
      }
    };

    /**
     * Set the orientation of the channel.
     * @param orientation
     */
    $scope.setOrientation = function setOrientation(orientation) {
      $scope.channel.orientation = orientation;
    };

    /**
     * Is the slide selected?
     * @param id
     * @returns {boolean}
     */
    $scope.slideSelected = function slideSelected(id) {
      var res = false;

      $scope.channel.slides.forEach(function (element) {
        if (id == element.id) {
          res = true;
        }
      });

      return res;
    };

    /**
     * Validates that @field is not empty on channel.
     */
    function validateNotEmpty(field) {
      if (!$scope.channel) {
        return false;
      }
      return $scope.channel[field] !== '';
    }

    /**
     * Handles the validation of the data in the channel.
     */
    $scope.validation = {
      titleSet: function () {
        return validateNotEmpty('title');
      },
      orientationSet: function () {
        return validateNotEmpty('orientation');
      }
    };

    /**
     * Select or deselect the slides related to a channel.
     * @param slide
     */
    $scope.toggleSlide = function toggleSlide(slide) {
      var res = null;

      $scope.channel.slides.forEach(function (element, index, array) {
        if (slide.id == element.id) {
          res = index;
        }
      });

      if (res !== null) {
        $scope.channel.slides.splice(res, 1);
      }
      else {
        $scope.channel.slides.push(slide);
      }
    };

    /**
     * Change channel creation step.
     * @param step
     */
    $scope.goToStep = function goToStep(step) {
      var s = 1;
      // If title is set enable next step.
      if ($scope.validation.titleSet()) {
        s++;
        // If orientation is set enable next three steps.
        if ($scope.validation.orientationSet()) {
          s = s + 3;
        }
      }
      if (step <= s) {
        loadStep(step);
      }
    };

    /**
     * Change the positioning of two array elements.
     * */
    function swapArrayEntries(arr, firstIndex, lastIndex) {
      var temp = arr[firstIndex];
      arr[firstIndex] = arr[lastIndex];
      arr[lastIndex] = temp;
    }

    /**
     * Push a channel slide right.
     * @param arrowPosition the position of the arrow.
     */
    $scope.pushRight = function pushRight(arrowPosition) {
      if (arrowPosition == $scope.channel.slides.length - 1) {
        swapArrayEntries($scope.channel.slides, arrowPosition, 0);
      }
      else {
        swapArrayEntries($scope.channel.slides, arrowPosition, arrowPosition + 1);
      }
    };

    /**
     * Push a channel slide right.
     * @param arrowPosition the position of the arrow.
     */
    $scope.pushLeft = function pushLeft(arrowPosition) {
      if (arrowPosition == 0) {
        swapArrayEntries($scope.channel.slides, arrowPosition, $scope.channel.slides.length - 1);
      }
      else {
        swapArrayEntries($scope.channel.slides, arrowPosition, arrowPosition - 1);
      }
    };
  }
]);
/**
 * @file
 * Channel overview controllers.
 */

/**
 * Channels controller handles the display and selection of channels.
 */
angular.module('ikApp').controller('ChannelOverviewController', ['$scope', 'sharedChannelFactory', 'channelFactory', 'itkLog',
  function($scope, sharedChannelFactory, channelFactory, itkLog) {
    'use strict';

    $scope.shareDialogShow = false;
    $scope.shareDialogChannel = null;

    // If the sharingService is enabled.
    if (window.config.sharingService.enabled) {
      $scope.$on('ikChannelShare.clickShare', function(event, channel) {
        $scope.shareDialogShow = true;
        $scope.shareDialogChannel = channel;

        channelFactory.getChannel(channel.id).then(
          function success(data) {
            $scope.shareDialogChannel = data;
            if (!$scope.shareDialogChannel.sharing_indexes) {
              $scope.shareDialogChannel.sharing_indexes = [];
            }
          },
          function error(reason) {
            itkLog.error('Hentning af kanal fejlede', reason);
          }
        );
      });

      $scope.sharingIndexes = [];
      sharedChannelFactory.getSharingIndexes().then(
        function success(data) {
          $scope.sharingIndexes = data;
        },
        function error(reason) {
          itkLog.error('Hentning af delingsindeks fejlede.', reason);
        }
      );

      $scope.saveSharingChannel = function saveSharingChannel() {
        channelFactory.channelShare($scope.shareDialogChannel).then(
          function() {
            itkLog.info('Delingskonfiguration af kanal lykkedes.', 3000);
          },
          function(reason) {
            itkLog.error('Deling af kanal fejlede.', reason);
          }
        );
      };
    }
  }
]);

/**
 * @file
 * Controllers for media edit
 */

/**
 * Media controller. Controls media editing functions.
 */
angular.module('ikApp').controller('MediaEditController', ['$scope', '$location', '$routeParams', '$timeout', 'mediaFactory', 'itkLog',
  function ($scope, $location, $routeParams, $timeout, mediaFactory, itkLog) {
    'use strict';

    // Get the selected media
    mediaFactory.getMedia($routeParams.id).then(
      function success(data) {
        $scope.media = data;

        if ($scope.media === {}) {
          $location.path('/media-overview');
        }
      },
      function error(reason) {
        itkLog.error("Kunne ikke hente media med id: " + $routeParams.id, reason);
        $location.path('/media-overview');
      }
    );

    /**
     * Delete an image.
     */
    $scope.delete = function () {
      mediaFactory.deleteMedia($scope.media.id).then(
        function success() {
          itkLog.info("Media slettet.", 3000);
          $timeout(function () {
            $location.path('/media-overview');
          }, 500);
        },
        function error(reason) {
          itkLog.error("Sletning af media fejlede.", reason);
        }
      );
    };

    /**
     * Get the content type of a media: image or media
     * @param media
     * @returns {*}
     */
    $scope.getContentType = function (media) {
      if (!media) {
        return "";
      }

      var type = media.content_type.split("/");
      return type[0];
    };

    /**
     * Sets the correct local path to the video
     *
     * @param element
     * The media element.
     *
     * @param format
     * The desired format to display (ogv, mpeg or thumbnail_SIZE).
     */
    $scope.videoPath = function (element, format) {
      // Init the filepath.
      var filepath = '';

      // Loop through the different video formats.
      element.provider_metadata.forEach(function (entry) {

        // Compare video format to desired format.
        if (entry.format === format) {
          filepath = entry.reference;
        }

        // Use thumbnail image.
        if (format === 'thumbnail_landscape') {
          // Use thumbnail from mp4 landscape.
          entry.thumbnails.forEach(function (thumbnail) {
            if (thumbnail.label === 'mp4_landscape') {
              filepath = thumbnail.reference;
            }
          });
        }
      });
      return filepath;
    }
  }
]);
/**
 * @file
 * Contains controllers for the media overview page.
 */

/**
 * Media controller handles the media overview page.
 */
angular.module('ikApp').controller('MediaOverviewController', ['$scope', '$location',
  function ($scope, $location) {
    'use strict';

    // Register event listener for the select media event.
    $scope.$on('mediaOverview.selectMedia', function(event, media) {
      $location.path('/media/' + media.id);
    });
  }
]);

/**
 * @file
 * Handles the media upload page
 */

/**
 * Media upload controller. Controls the media upload page.
 */
angular.module('ikApp').controller('MediaUploadController', ['$scope',
  function ($scope) {
    'use strict';

    // Register event listener for uploadComplete action.
    $scope.$on('mediaUpload.uploadComplete', function(event, data) {

    });
  }
]);

/**
 * @file
 * Contains screen controller.
 */

/**
 * Screen controller. Controls the screen creation process.
 */
angular.module('ikApp').controller('ScreenController', ['$scope', '$location', '$routeParams', 'screenFactory', 'channelFactory', 'sharedChannelFactory', 'templateFactory', 'itkLog', '$timeout',
  function ($scope, $location, $routeParams, screenFactory, channelFactory, sharedChannelFactory, templateFactory, itkLog, $timeout) {
    'use strict';

    $scope.loading = true;
    $scope.sharingEnabled = window.config.sharingService.enabled;
    $scope.screen = {};
    $scope.toolbarTemplate = null;
    $scope.display = false;
    $scope.region = null;

    /**
     * Constructor.
     * Handles different settings of route parameters.
     */
    function init() {
      if (!$routeParams.id) {
        // If the ID is not set, get an empty slide.
        $scope.screen = screenFactory.emptyScreen();

        // Default to full-screen template if it exists, else pick the first available.
        templateFactory.getScreenTemplate('full-screen').then(
          function (data) {
            $scope.screen.template = data;
            $scope.loading = false;
          },
          function (reason) {
            if (reason === 404) {
              templateFactory.getScreenTemplates().then(
                function success(data) {
                  $scope.screen.template = angular.copy(data[0]);
                  $scope.screen.orientation = data[0].orientation;

                  $scope.loading = false;
                },
                function error(reason) {
                  itkLog.error("Skabelonerne blev ikke loaded", reason);
                }
              );
            }
          }
        );
      }
      else {
        if ($routeParams.id === null || $routeParams.id === undefined || $routeParams.id === '') {
          $location.path('/screen-overview');
        } else {
          // Get the screen from the backend.
          screenFactory.getEditScreen($routeParams.id).then(
            function success(data) {
              $scope.loading = false;

              $scope.screen = data;

              // Decode the shared channels.
              $scope.screen.channel_screen_regions.forEach(function (csr) {
                if (csr.shared_channel) {
                  // Parse the content of the shared channel
                  //   Set title and slides of the shared_channel.
                  csr.shared_channel.content = JSON.parse(csr.shared_channel.content);
                  csr.shared_channel.title = csr.shared_channel.content.title;
                  csr.shared_channel.slides = csr.shared_channel.content.slides;
                }
              });

              if ($scope.screen === {}) {
                $location.path('/screen');
              }
            },
            // Error getting
            function error(reason) {
              itkLog.error("Skærmen med id: " + $routeParams.id + " blev ikke fundet", reason);
            }
          );
        }
      }
    }

    init();

    /**
     * Save the screen and close.
     */
    $scope.saveScreenAndClose = function saveScreenAndClose() {
      $scope.displayToolbar = false;
      $scope.region = null;
      screenFactory.saveScreen().then(
        function success() {
          itkLog.info("Skærmen er gemt", 3000);

          // Redirect to overview.
          $timeout(function () {
            $location.path('/screen-overview');
          }, 1000);
        },
        function error(reason) {
          itkLog.error("Skærmen blev ikke gemt", reason);
        }
      );
    };

    /**
     * Save the screen.
     */
    $scope.saveScreen = function saveScreen() {
      $scope.displayToolbar = false;
      $scope.region = null;
      screenFactory.saveScreen().then(
        function success() {
          itkLog.info("Skærmen er gemt", 3000);
        },
        function error(reason) {
          itkLog.error("Skærmen blev ikke gemt", reason);
        }
      );
    };

    /**
     * Trigger the tool defined in the tool parameter.
     * @param tool
     *   The tool and region to trigger.
     */
    $scope.triggerTool = function triggerTool(tool) {
      //Check if the current screen template provides the tool.
      if ($scope.screen.template.tools.hasOwnProperty(tool.name)) {
        $scope.toolbarTemplate = $scope.screen.template.tools[tool.name];
      }
      else {
        // Fallback to default tools.
        $scope.toolbarTemplate = 'app/shared/toolbars/' + tool.name + '.html';
      }
      $scope.region = tool.region;
      $scope.displayToolbar = true;
    };
  }
]);

/**
 * @file
 * Screen overview controllers.
 */

/**
 * Screens controller handles the display and selection of screens.
 */
angular.module('ikApp').controller('ScreenOverviewController', ['$scope', 'screenFactory', 'userFactory', 'itkLog',
  function($scope, screenFactory, userFactory, itkLog) {
    'use strict';

    $scope.loading = false;

    // Set default values.
    $scope.showFromUser = 'all';
    $scope.sort = { "created_at": "desc" };

    userFactory.getCurrentUser().then(
      function success(data) {
        $scope.currentUser = data;
      },
      function error(reason) {
        itkLog.error('Kunne ikke hente bruger.', reason);
      }
    );

    // Default pager values.
    $scope.pager = {
      "size": 6,
      "page": 0
    };
    $scope.hits = 0;

    // Screens to display.
    $scope.screens = [];

    // Setup default search options.
    var search = {
      "fields": [ 'title' ],
      "text": '',
      "sort": {
        "created_at" : {
          "order": "desc"
        }
      },
      'pager': $scope.pager
    };

    /**
     * Updates the screens array by send a search request.
     */
    $scope.updateSearch = function() {
      // Get search text from scope.
      search.text = $scope.search_text;

      $scope.loading = true;

      screenFactory.searchScreens(search).then(
        function(data) {
          // Total hits.
          $scope.hits = data.hits;

          // Extract search ids.
          var ids = [];
          for (var i = 0; i < data.results.length; i++) {
            ids.push(data.results[i].id);
          }

          // Load slides bulk.
          screenFactory.loadScreensBulk(ids).then(
            function (data) {
              $scope.screens = data;

              $scope.loading = false;
            },
            function (reason) {
              itkLog.error('Kunne ikke hente søgeresultater.', reason);
              $scope.loading = false;
            }
          );
        }
      );
    };

    /**
     * Update search result on screen deletion.
     */
    $scope.$on('screen-deleted', function() {
      $scope.updateSearch();
    });

    // Send the default search query.
    $scope.updateSearch();

    /**
     * Changes if all slides are shown or only slides belonging to current user
     *
     * @param user
     *   This should either be 'mine' or 'all'.
     */
    $scope.setUser = function setUser(user) {
      if ($scope.showFromUser !== user) {
        $scope.showFromUser = user;

        $scope.setSearchFilters();
        $scope.updateSearch();
      }
    };

    /**
     * Updates the search filter based on current orientation and user
     */
    $scope.setSearchFilters = function setSearchFilters() {
      // Update orientation for the search.
      delete search.filter;

      if($scope.showFromUser !== 'all') {
        search.filter = {
          "bool": {
            "must": []
          }
        }
      }

      if ($scope.showFromUser !== 'all') {
        var term = {};
        term.term = {user : $scope.currentUser.id};
        search.filter.bool.must.push(term);
      }

      $scope.updateSearch();
    };

    /**
     * Changes the sort order and updated the screens.
     *
     * @param sort_field
     *   Field to sort on.
     * @param sort_order
     *   The order to sort in 'desc' or 'asc'.
     */
    $scope.setSort = function(sort_field, sort_order) {
      // Only update search if sort have changed.
      if ($scope.sort[sort_field] === undefined || $scope.sort[sort_field] !== sort_order) {

        // Update the store sort order.
        $scope.sort = { };
        $scope.sort[sort_field] = sort_order;

        // Update the search variable.
        search.sort = { };
        search.sort[sort_field] = {
          "order": sort_order
        };

        $scope.updateSearch();
      }
    };
  }
]);

/**
 * @file
 * Shared channel creation controllers.
 */

/**
 * Shared channel controller. Controls the channel creation process.
 */
angular.module('ikApp').controller('SharedChannelController', ['$scope', '$location', '$routeParams', '$timeout', 'screenFactory', 'sharedChannelFactory', 'itkLog',
  function ($scope, $location, $routeParams, $timeout, screenFactory, sharedChannelFactory, itkLog) {
    'use strict';

    $scope.steps = 1;
    $scope.step = 1;
    $scope.channel = {};
    $scope.channel.slides = [];
    $scope.status = 'edit';

    // Get all screens.
    screenFactory.getScreens().then(
      function success(data) {
        $scope.screens = data;
      },
      function error(reason) {
        itkLog.error('Kunne ikke hente bruger.', reason);
      }
    );

    /**
     * Loads a given step.
     */
    function loadStep(step) {
      $scope.step = step;
      $scope.templatePath = '/app/pages/sharedChannel/shared-channel-step' + $scope.step + '.html';
    }

    /**
     * Constructor.
     * Handles different settings of route parameters.
     */
    function init() {
      if (!$routeParams.id || !$routeParams.index) {
        $location.path('/channel-sharing-overview');
      } else {
        sharedChannelFactory.getSharedChannel($routeParams.id, $routeParams.index).then(
          function success(data) {
            $scope.channel = JSON.parse(data.content);

            if ($scope.channel === {}) {
              $location.path('/channel-sharing-overview');
            }

            loadStep(1);
          },
          function error(reason) {
            itkLog.error("Delt kanal kunne ikke hentes.", reason);
          }
        );
      }
    }

    init();

    /**
     * Submit a step in the installation process.
     */
    $scope.submitStep = function () {
      $location.path('/channel-sharing-overview');
    };

    /**
     * Change channel creation step.
     * @param step
     */
    $scope.goToStep = function (step) {
      loadStep(step);
    };
  }
]);
/**
 * @file
 * Channel creation controllers.
 */

/**
 * Shared channel overview controller. Controls the sharing channel overview.
 */
angular.module('ikApp').controller('SharedChannelOverviewController', ['$scope',
  function($scope) {
    'use strict';

  }
]);
/**
 * @file
 * Slide creation controllers.
 */

/**
 * Slide controller. Controls the slide creation/edit process.
 */
angular.module('ikApp').controller('SlideController', ['$scope', '$location', '$routeParams', '$timeout', 'slideFactory', 'templateFactory', 'channelFactory', 'itkLog',
  function ($scope, $location, $routeParams, $timeout, slideFactory, templateFactory, channelFactory, itkLog) {
    'use strict';

    $scope.steps = 5;
    $scope.slide = {};
    $scope.templates = [];
    templateFactory.getSlideTemplates().then(
      function success(data) {
        for (var key in data) {
          if (data.hasOwnProperty(key)) {
            $scope.templates.push(data[key]);
          }
        }
      },
      function error(reason) {
        itkLog.error("Kunne ikke hente slide templates.", reason);
      }
    );
    $scope.channels = [];

    // Setup the editor.
    $scope.editor = {
      channelOverviewEditor: false,
      toggleChannelOverviewEditor: function () {
        $('html').toggleClass('is-locked');
        $scope.editor.channelOverviewEditor = !$scope.editor.channelOverviewEditor;
      }
    };

    // Register event listener for clickSlide.
    $scope.$on('channelOverview.clickChannel', function (event, channel) {
      $scope.toggleChannel(channel);
    });

    /**
     * Load a given step
     */
    function loadStep(step) {
      $scope.step = step;
      $scope.templatePath = '/app/pages/slide/slide-step' + $scope.step + '.html';
    }

    /**
     * Constructor.
     * Handles different settings of route parameters.
     */
    function init() {
      // Get all channels for step 6
      channelFactory.getChannels().then(function (data) {
        $scope.channels = data;
      });

      if (!$routeParams.id) {
        // If the ID is not set, get an empty slide.
        $scope.slide = slideFactory.emptySlide();
        $scope.slide.channels = [];
        loadStep(1);
      }
      else {
        if ($routeParams.id === null || $routeParams.id === undefined || $routeParams.id === '') {
          $location.path('/slide');
        }
        else {
          // Make sure we load a fresh version of the slide.
          slideFactory.clearCurrentSlide();

          // Get the slide from the backend.
          slideFactory.getEditSlide($routeParams.id).then(
            function success(data) {
              $scope.slide = data;
              $scope.slide.status = 'edit-slide';
              if ($scope.slide === {}) {
                $location.path('/slide');
              }

              // Go to step 3 (edit content)
              loadStep(3);
            },
            function error(reason) {
              itkLog.error("Kunne ikke hente slide med id: " + $routeParams.id, reason);
              $location.path('/slide-overview');
            }
          );
        }
      }
    }

    init();

    /**
     * Submit a step in the installation process.
     */
    $scope.submitStep = function () {
      if ($scope.step === $scope.steps) {
        $scope.disableSubmitButton = true;

        // Set default duration if none is set.
        if ($scope.slide.duration === '') {
          $scope.slide.duration = 15;
        }

        slideFactory.saveSlide().then(
          function success() {
            itkLog.info("Slide gemt.", 3000);

            $timeout(function () {
              $location.path('/slide-overview');
            }, 1000);
          },
          function error(reason) {
            itkLog.error("Kunne ikke gemme slide.", reason);
            $scope.disableSubmitButton = false;
          }
        );
      }
      else {
        loadStep($scope.step + 1);
      }
    };

    /**
     * Validates that @field is not empty on slide.
     */
    function validateNotEmpty(field) {
      if (!$scope.slide) {
        return false;
      }
      return $scope.slide[field] !== '';
    }

    /**
     * Handles the validation of the data in the slide.
     */
    $scope.validation = {
      titleSet: function () {
        return validateNotEmpty('title');
      },
      templateSet: function () {
        return validateNotEmpty('template');
      }
    };

    /**
     * Go the given step in the creation process, if the requirements have been met to be at that step.
     * @param step
     */
    $scope.goToStep = function (step) {
      var s = 1;
      if ($scope.validation.titleSet()) {
        s++;
        if ($scope.validation.templateSet()) {
          s = s + 3;
        }
      }
      if (step <= s) {
        loadStep(step);
      }
    };

    /**
     * Set the template id of a slide.
     * Update the options attribute to add fields that are needed for the template.
     *
     * @param id
     */
    $scope.selectTemplate = function (id) {
      // Set name of template.
      $scope.slide.template = id;

      // Find selected template.
      var template = null;
      $scope.templates.forEach(function (element) {
        if (element.id === id) {
          template = element;
        }
      });

      // Bail out if no template is selected.
      if (template === null) {
        return;
      }

      // Set calendar type
      $scope.slide.slide_type = template.slide_type;

      // Make sure the options field has been set.
      if (!$scope.slide.options) {
        $scope.slide.options = {};
      }

      // Set orientation.
      $scope.slide.orientation = template.orientation;

      // Update options field.
      angular.forEach(template.empty_options, function (value, key) {
        if ($scope.slide.options[key] === undefined) {
          $scope.slide.options[key] = angular.copy(value);
        }
      });

      // Set the headline equal to the title, if it is empty.
      if ($scope.slide.options.headline === '') {
        $scope.slide.options.headline = $scope.slide.title;
      }

      // Get the media type from the template.
      $scope.slide.media_type = template.media_type;
    };

    /**
     * Is the channel selected?
     * @param channel
     * @returns {boolean}
     */
    $scope.channelSelected = function (channel) {
      var res = false;

      $scope.slide.channels.forEach(function (slideChannel) {
        if (channel.id === slideChannel.id) {
          res = true;
        }
      });

      return res;
    };

    /**
     * Check if channel is included in the current screen.
     * @param channel
     * @returns {boolean}
     */
    $scope.hasChannel = function hasChannel(channel) {
      var res = false;

      $scope.slide.channels.forEach(function (element) {
        if (channel.id === element.id) {
          res = true;
        }
      });
      return res;
    };

    /**
     * Add remove a channel.
     * @param channel
     */
    $scope.toggleChannel = function (channel) {
      var index = null;

      $scope.slide.channels.forEach(function (slideChannel, channelIndex) {
        if (channel.id === slideChannel.id) {
          index = channelIndex;
        }
      });

      if (index !== null) {
        $scope.slide.channels.splice(index, 1);
      }
      else {
        $scope.slide.channels.push(channel);
      }
    };
  }
]);
/**
 * @file
 * Contains slide edit controller.
 */

/**
 * Slide edit controller. Controls the editors for the slide creation process.
 */
angular.module('ikApp').controller('SlideEditController', ['$scope', '$http', '$filter', 'mediaFactory', 'slideFactory', 'kobaFactory', 'itkLog', 'templateFactory',
  function ($scope, $http, $filter, mediaFactory, slideFactory, kobaFactory, itkLog, templateFactory) {
    'use strict';

    $scope.step = 'background-picker';
    $scope.addevent = {
      "title": null,
      "place": null,
      "from": null,
      "to": null
    };

    // Get the slide from the backend.
    slideFactory.getEditSlide(null).then(
      function success(data) {
        $scope.slide = data;

        templateFactory.getSlideTemplate(data.template).then(
          function success(data) {
            $scope.template = data;
          },
          function error(reason) {
            itkLog.error('Kunne ikke loade værktøjer til slidet.', reason);
          }
        );
      },
      function error(reason) {
        itkLog.error("Kunne ikke hente slide.", reason);
      }
    );

    /**
     * Open the selected tool.
     * @param tool
     */
    $scope.openTool = function openTool(tool) {
      $('html').toggleClass('is-locked');
      if (!$scope.editor.editorOpen) {
        $scope.editor.editorOpen = true;
        $scope.editorURL = 'app/shared/elements/slide/editors/' + tool.id + '.html';

        if (tool.id === 'manual-calendar-editor') {
          // Reset input fields.
          $scope.addevent.title = null;
          $scope.addevent.place = null;
          $scope.addevent.from = null;
          $scope.addevent.to = null;
          // Run sorting of events.
          $scope.sortEvents();
          $scope.validateEvents();
        }
        else if (tool.id === 'event-calendar-editor') {
          kobaFactory.getResources().then(
            function (data) {
              $scope.availableResources = data;
            }
          );
        }

      } else {
        $scope.editor.editorOpen = false;
        $scope.editorURL = '';
      }
    };

    // Setup editor states and functions.
    $scope.editor = {
      editorOpen: false,
      hideEditors: function hideEditors() {
        $scope.editor.editorOpen = false;
        $scope.editorURL = '';
      }
    };

    /**
     * When clicking the background color button,
     * remove selected images.
     */
    $scope.clickBackgroundColor = function clickBackgroundColor() {
      $scope.slide.options.images = [];
    };

    /**
     * Add event to slide
     */
    $scope.addEventItem = function addEventItem() {
      var event = {
        "title": $scope.addevent.title,
        "place": $scope.addevent.place,
        "from": $scope.addevent.from,
        "to": $scope.addevent.to
      };

      // Add event data to slide array.
      $scope.slide.options.eventitems.push(event);

      // Reset input fields.
      $scope.addevent.title = null;
      $scope.addevent.place = null;
      $scope.addevent.from = null;
      $scope.addevent.to = null;

      event = null;
    };

    /**
     * Remove event from slide.
     */
    $scope.removeEventItem = function removeEventItem(event) {
      $scope.slide.options.eventitems.splice($scope.slide.options.eventitems.indexOf(event), 1);
    };

    /**
     * Sort events for slide.
     */
    $scope.sortEvents = function sortEvents() {
      if ($scope.slide.options.eventitems.length > 0) {
        // Sort the events by from date.
        $scope.slide.options.eventitems = $filter('orderBy')($scope.slide.options.eventitems, "from")
      }
    };

    /**
     * Is outdated for events on slide
     */
    $scope.eventIsOutdated = function setOutdated(event) {
      var to = event.to;
      var from = event.from;
      var now = Date.now() / 1000;

      return (to && now > to) || (!to && now > from);
    };

    /**
     * Validate events related to the slide.
     */
    $scope.validateEvents = function validateEvents() {
      if ($scope.slide.options.eventitems.length > 0) {
        // Run through all events.
        for (var i = 0; i < $scope.slide.options.eventitems.length; i++) {
          var item = $scope.slide.options.eventitems[i];

          if (item.from && !item.to) {
            item.dailyEvent = true;
          }
          else {
            var fromDate = new Date(item.from * 1000);
            var toDate = new Date(item.to * 1000);

            return fromDate.getDate() === toDate.getDate();
          }

          // Save new event item with duration.
          $scope.slide.options.eventitems[i] = item;
        }
      }
    };

    /**
     * Add calendar events from source (for event calendar.)
     */
    $scope.addCalendarEvents = function addCalendarEvents() {
      var arr = [];

      // Process bookings for each resource.
      var addResourceBookings = function (data) {
        for (var i = 0; i < data.length; i++) {
          var event = data[i];
          arr.push(event);
        }
      };

      // Get bookings for each resource.
      for (var i = 0; i < $scope.slide.options.resources.length; i++) {
        var resource = $scope.slide.options.resources[i];
        var now = new Date();
        var todayStart = (new Date(now.getFullYear(), now.getMonth(), now.getDate())).getTime() / 1000;
        var todayEnd = todayStart + 86400;

        kobaFactory.getBookingsForResource(resource.mail, todayStart, todayEnd).then(
          addResourceBookings,
          function error(reason) {
            itkLog.error("Kunne ikke hente bookings for ressource", reason);
          }
        );
      }

      $scope.slide.calendar_events = arr;
    };

    // Register event listener for select media.
    $scope.$on('mediaOverview.selectMedia', function (event, media) {
      if (media.media_type === 'logo') {
        $scope.slide.logo = media;

        $scope.logoStep = 'logo-picker';
      }
      else {
        var containsMedia = false;

        $scope.slide.media.forEach(function (element) {
          if (element.id === media.id) {
            containsMedia = true;
          }
        });

        if (containsMedia) {
          $scope.slide.media.length = 0;
        }
        else {
          $scope.slide.media.length = 0;
          $scope.slide.media.push(media);
        }

        // Hide editors.
        $scope.editor.hideEditors();
      }
    });

    // Register event listener for media upload success.
    $scope.$on('mediaUpload.uploadSuccess', function (event, data) {
      var allSuccess = true;

      for (var i = 0; i < data.queue.length; i++) {
        var item = data.queue[i];

        if (!item.isSuccess) {
          allSuccess = false;
          break;
        }
      }

      // If all the data items were uploaded correctly.
      if (allSuccess) {
        mediaFactory.getMedia(data.id).then(
          function success(media) {
            if (media.media_type === 'logo') {
              $scope.slide.logo = media;

              $scope.logoStep = 'logo-picker';
            }
            else {
              $scope.slide.media.length = 0;
              $scope.slide.media.push(media);

              // Hide editors.
              $scope.editor.hideEditors();
            }
          },
          function error(reason) {
            itkLog.error("Kunne ikke tilføje media.", reason);
          }
        );
      }
    });


    $scope.step = 'background-picker';

    /**
     * Set the step to background-picker.
     */
    $scope.backgroundPicker = function backgroundPicker() {
      $scope.step = 'background-picker';
    };

    /**
     * Set the step to pick-from-media.
     */
    $scope.pickFromMedia = function pickFromMedia() {
      $scope.step = 'pick-from-media';
      $scope.$emit('mediaOverview.updateSearch');
    };

    /**
     * Set the step to pick-from-computer.
     */
    $scope.pickFromComputer = function pickFromComputer() {
      $scope.step = 'pick-from-computer';
    };

    $scope.logoStep = 'logo-picker';

    /**
     * Set the step to logo-picker.
     */
    $scope.logoPicker = function logoPicker() {
      $scope.logoStep = 'logo-picker';
    };

    /**
     * Set the step to pick-logo-from-media.
     */
    $scope.pickLogoFromMedia = function pickLogoFromMedia() {
      $scope.logoStep = 'pick-logo-from-media';
      $scope.$emit('mediaOverview.updateSearch');
    };

    /**
     * Set the step to pick-logo-from-computer.
     */
    $scope.pickLogoFromComputer = function pickLogoFromComputer() {
      $scope.logoStep = 'pick-logo-from-computer';
    };

    /**
     * Available logo positions.
     */
    $scope.logoPositions = [
      {
        value: {
          'top': '0',
          'bottom': 'auto',
          'left': '0',
          'right': 'auto'
        },
        text: 'top venstre'
      },
      {
        value: {
          'top': '0',
          'bottom': 'auto',
          'left': 'auto',
          'right': '0'
        },
        text: 'top højre'
      },
      {
        value: {
          'top': 'auto',
          'bottom': '0',
          'left': '0',
          'right': 'auto'
        },
        text: 'bund venstre'
      },
      {
        value: {
          'top': 'auto',
          'bottom': '0',
          'left': 'auto',
          'right': '0'
        },
        text: 'bund højre'
      }
    ];

    /**
     * Available logo sizes.
     */
    $scope.logoSizes = [
      {
        value: "5%",
        text: "Meget lille (5% af skærmen)"
      },
      {
        value: "10%",
        text: "Lille (10% af skærmen)"
      },
      {
        value: "15%",
        text: "Medium (15% af skærmen)"
      },
      {
        value: "20%",
        text: "Stor (20% af skærmen)"
      },
      {
        value: "40%",
        text: "Ekstra stor (40% af skærmen)"
      }
    ];
  }
]);

/**
 * @file
 * Slide overview controllers.
 */

/**
 * Slide overview controller handles the display and selection of slides.
 */
angular.module('ikApp').controller('SlideOverviewController', ['$scope', '$location',
  function($scope, $location) {
    'use strict';

    // Register event listener for the click slide event.
    $scope.$on('slideOverview.clickSlide', function(event, slide) {
      $location.path('/slide/' + slide.id);
    });
  }
]);

/**
 * @file
 * Contains the activeEvents filter.
 * A filter to display only events that have not yet bypassed their end date.
 */

/**
 * Add an active events filter to eventlist.
 */
angular.module('ikApp').filter('activeEvents', function () {
  'use strict';

  return function (items) {
    // Return if event array empty.
    if (!angular.isArray(items)) {
      return false
    }

    // Get current time.
    var currentTime = parseInt(Date.now() / 1000);

    var ret = [];

    // Loop through event items.
    for (var i = 0; i < items.length; i++) {
      var item = items[i];

      // Calculate event duration.
      if (item.from && item.to && item.to >= currentTime) {
        ret.push(item);
      }
      else if (item.from && item.from >= currentTime) {
        ret.push(item);
      }
    }

    return ret;
  };
});
/**
 * @file
 * Contains the reverseEvents filter.
 */

/**
 * Add a reverse filter to eventlist.
 */
angular.module('ikApp').filter('reverseEvents', function () {
  'use strict';

  return function (items) {
    if (!angular.isArray(items)) {
      return false
    }

    // Turn the list upside down.
    return items.slice().reverse();
  };
});

/**
 * @file
 * Contains the controller for the menues.
 */

/**
 * Menu controller. Controls the menues.
 */
angular.module('ikApp').controller('MenuController', ['$scope', '$rootScope', '$location', '$http', 'userFactory', 'itkLog',
  function ($scope, $rootScope, $location, $http, userFactory, itkLog) {
    'use strict';

    $scope.url = $location.url();
    $scope.navMenuOpen = null;
    $scope.subMenuItems = [];
    $scope.showMobileMainMenu = false;
    $scope.showSharingOptions = window.config.sharingService.enabled;
    $scope.siteTitle = window.config.siteTitle;

    userFactory.getCurrentUser().then(
      function success(data) {
        $scope.currentUser = data;
      },
      function error(reason) {
        itkLog.error("Hentning af bruger fejlede.", reason);
      }
    );

    /**
     * Set the submenu items according to what the url starts with.
     */
    var updateSubMenu = function () {
      if ($scope.url.indexOf('/channel') === 0 || $scope.url.indexOf('/shared-channel') === 0) {
        $scope.subMenuItems = [
          {
            title: 'Oversigt',
            path: 'channel-overview',
            classSuffix: 'overview'
          },
          {
            title: 'Opret kanal',
            path: 'channel',
            classSuffix: 'create-channel'
          }
        ];

        if ($scope.showSharingOptions) {
          $scope.subMenuItems.push(
            {
              title: 'Delte kanaler',
              path: 'shared-channel-overview',
              classSuffix: 'overview'
            }
          );
        }
      }
      else if ($scope.url.indexOf('/slide') === 0) {
        $scope.subMenuItems = [
          {
            title: 'Oversigt',
            path: 'slide-overview',
            classSuffix: 'overview'
          },
          {
            title: 'Opret slide',
            path: 'slide',
            classSuffix: 'create-channel'
          }
        ];
      }
      else if ($scope.url.indexOf('/screen') === 0) {
        $scope.subMenuItems = [
          {
            title: 'Oversigt',
            path: 'screen-overview',
            classSuffix: 'overview'
          },
          {
            title: 'Opret skærm',
            path: 'screen',
            classSuffix: 'create-channel'
          }
        ];
      }
      else if ($scope.url.indexOf('/template') === 0) {
        $scope.subMenuItems = [
          {
            title: 'Oversigt',
            path: 'template-overview',
            classSuffix: 'overview'
          },
          {
            title: 'Opret skabelon',
            path: 'template',
            classSuffix: 'create-channel'
          }
        ];
      }
      else if ($scope.url.indexOf('/media') === 0) {
        $scope.subMenuItems = [
          {
            title: 'Oversigt',
            path: 'media-overview',
            classSuffix: 'overview'
          },
          {
            title: 'Upload medie',
            path: 'media/upload',
            classSuffix: 'create-media'
          }
        ];
      }
      else {
        $scope.subMenuItems = [];
      }
    };
    updateSubMenu();

    /**
     * Function to see if the first part of a path matches the pattern.
     * @param str
     * @param pattern
     * @returns {boolean}
     */
    $scope.pathStartsWith = function (str, pattern) {
      var split = str.split('/');

      if (split.length >= 2) {
        str = "";
        for (var i = 1; i < split.length; i++) {
          str = str + split[i];
          if (i < split.length - 1) {
            str = str + "/";
          }
        }
      }

      return str === pattern;
    };

    /**
     * Open/Close navigation menu.
     */
    $scope.toggleNavMenu = function () {
      if ($scope.navMenuOpen === null) {
        $scope.navMenuOpen = false;
      }
      $scope.navMenuOpen = !$scope.navMenuOpen;
      $('html').toggleClass('is-locked');
    };

    var closeNavMenu = function() {
      if ($scope.navMenuOpen === null) {
        $scope.navMenuOpen = false;
      }
      $scope.navMenuOpen = false;
      $('html').removeClass('is-locked');
    };

    /**
     * Setup listener for when the url changes.
     */
    $rootScope.$on('$locationChangeSuccess', function () {
      $scope.url = $location.url();
      $scope.navMenuOpen = false;
      $('html').removeClass('is-locked');
      updateSubMenu();

      // Clear log
      itkLog.clear();
    });

    /**
     * Show/hide mobile main menu.
     */
    $scope.mobileMainMenuVisible = function () {
      return $scope.url.indexOf('/channel') == 0 && $scope.url.indexOf('/slide') == 0 && $scope.url.indexOf('/screen') == 0 && $scope.url.indexOf('/media') == 0;
    };

    /**
     * Update templates.
     */
    $scope.updateTemplates = function updateTemplates() {
      $http.get('/api/command/update_templates')
        .success(function(data, status, headers, config) {
          itkLog.info("Templates opdateret.", 3000);
        })
        .error(function(data, status, headers, config) {
          itkLog.error("Update af templates fejlede.", status);
        });
      closeNavMenu();
    };

    /**
     * Reindex search.
     */
    $scope.reindex = function reindex() {
      $http.get('/api/command/reindex')
        .success(function(data, status, headers, config) {
          itkLog.info("Reindex gennemført.", 3000);
        })
        .error(function(data, status, headers, config) {
          itkLog.error("Reindex fejlede.", status);
        });
      closeNavMenu();
    };

    /**
     * Force push.
     */
    $scope.forcePush = function reindex() {
      $http.get('/api/command/forcepush')
        .success(function(data, status, headers, config) {
          itkLog.info("Force push gennemført.", 3000);
        })
        .error(function(data, status, headers, config) {
          itkLog.error("Force push fejlede.", status);
        });
      closeNavMenu();
    };
  }
]);



/**
 * @file
 * Contains the authentication http interceptor factory.
 *
 * Listen to all calls through $httpProvider and intercepts and redirects to /login if
 * response is a "401 Unauthorized"
 */

/**
 * Interceptor for 401 (unauthorized) responses.
 * Logs out.
 */
angular.module('ikApp').factory('authHttpResponseInterceptor', ['$q', '$location', '$window',
  function ($q, $location, $window) {
    'use strict';

    return {
      responseError: function (rejection) {
        if (rejection.status === 401) {
          $window.location.href = "/login";
        }
        return $q.reject(rejection);
      }
    }
  }
]);

/**
 * Register the event interceptor.
 */
angular.module('ikApp').config(['$httpProvider', function ($httpProvider) {
  'use strict';

  $httpProvider.interceptors.push('authHttpResponseInterceptor');
}]);
/**
 * @file
 * Contains the channel factory.
 */

/**
 * Channel factory. Main entry point for accessing channels.
 */
angular.module('ikApp').factory('channelFactory', ['$http', '$q', 'searchFactory',
  function ($http, $q, searchFactory) {
    'use strict';

    var factory = {};

    // Current open channel.
    // This is the channel we are editing.
    var currentChannel = {};

    /**
     * Search via search_node.
     * @param search
     * @returns {*|Number}
     */
    factory.searchChannels = function (search) {
      search.type = 'Indholdskanalen\\MainBundle\\Entity\\Channel';
      return searchFactory.search(search);
    };

    /**
     * Get all channels.
     */
    factory.getChannels = function () {
      var defer = $q.defer();

      $http.get('/api/channels')
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function () {
          defer.reject();
        });

      return defer.promise;
    };

    /**
     * Load the channels with the given ids.
     *
     * @param ids
     */
    factory.loadChannelsBulk = function loadChannelsBulk(ids) {
      var defer = $q.defer();

      // Build query string.
      var queryString = "?";
      for (var i = 0; i < ids.length; i++) {
        queryString = queryString + "ids[]=" + ids[i];
        if (i < ids.length - 1) {
          queryString = queryString + "&";
        }
      }

      // Load bulk.
      $http.get('/api/channels/bulk' + queryString)
        .success(function (data, status) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Find slide to edit. If id is not set return current slide, else load from backend.
     * @param id
     */
    factory.getEditChannel = function (id) {
      var defer = $q.defer();

      if (id === null || id === undefined || id === '') {
        defer.resolve(currentChannel);
      } else {
        $http.get('/api/channel/' + id)
          .success(function (data) {
            currentChannel = data;
            defer.resolve(currentChannel);
          })
          .error(function () {
            defer.reject();
          });
      }

      return defer.promise;
    };

    /**
     * Find the channel with @id
     * @param id
     */
    factory.getChannel = function (id) {
      var defer = $q.defer();

      $http.get('/api/channel/' + id)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function () {
          defer.reject();
        });

      return defer.promise;
    };

    /**
     * Returns an empty channel.
     */
    factory.emptyChannel = function () {
      currentChannel = {
        id: null,
        title: '',
        orientation: '',
        created_at: parseInt((new Date().getTime()) / 1000),
        slides: [],
        screens: [],
        sharing_indexes: [],
        schedule_repeat_days: []
      };

      return currentChannel;
    };

    /**
     * Saves channel to channels. Assigns an id, if it is not set.
     */
    factory.saveChannel = function () {
      var defer = $q.defer();

      $http.post('/api/channel', currentChannel)
        .success(function () {
          defer.resolve("success");
          currentChannel = null;
        })
        .error(function () {
          defer.reject("error");
        });

      return defer.promise;
    };

    /**
     * Update which indexes a channel is shared with.
     * @param channel
     * @returns {*}
     */
    factory.channelShare = function (channel) {
      var defer = $q.defer();

      $http.post('/api/channel/share', channel)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    return factory;
  }
]);

/**
 * @file
 * Contains the channel factory.
 */

/**
 * Koba factory.
 */
angular.module('ikApp').factory('kobaFactory', ['$http', '$q',
  function ($http, $q) {
    'use strict';

    var factory = {};

    /**
     * Get available resources.
     * @returns {*}
     */
    factory.getResources = function getResources() {
      var defer = $q.defer();

      $http.get('/api/resources')
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Get Bookings for resource for interval between from and to.
     *
     * @param resourceMail
     *   Resource mail.
     * @param from
     *   Unix timestamp
     * @param to
     *   Unix timestamp
     * @returns {*}
     */
    factory.getBookingsForResource = function getBookingsForResource(resourceMail, from, to) {
      var defer = $q.defer();

      $http.get('/api/resources/' + resourceMail + '/bookings/from/' + from + '/to/' + to)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    return factory;
  }
]);

/**
 * @file
 * Contains the media factory.
 */

/**
 * Media factory. Main entry to media.
 */
angular.module('ikApp').factory('mediaFactory', ['$http', '$q', 'searchFactory',
  function ($http, $q, searchFactory) {
    'use strict';

    var factory = {};

    /**
     * Get all media.
     */
    factory.getAllMedia = function () {
      var defer = $q.defer();

      $http.get('/api/media')
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function () {
          defer.reject();
        });

      return defer.promise;
    };

    /**
     * Search for media defined by search parameter.
     * @param search
     */
    factory.searchMedia = function (search) {
      search.type = 'Application\\Sonata\\MediaBundle\\Entity\\Media';
      return searchFactory.search(search);
    };

    /**
     * Load the screens with the given ids.
     *
     * @param ids
     */
    factory.loadMediaBulk = function loadMediaBulk(ids) {
      var defer = $q.defer();

      // Build query string.
      var queryString = "?";
      for (var i = 0; i < ids.length; i++) {
        queryString = queryString + "ids[]=" + ids[i];
        if (i < ids.length - 1) {
          queryString = queryString + "&"
        }
      }

      // Load bulk.
      $http.get('/api/media/bulk' + queryString)
        .success(function (data, status) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status)
        });

      return defer.promise;
    };

    /**
     * Find the media with @id
     * @param id
     */
    factory.getMedia = function (id) {
      var defer = $q.defer();

      $http.get('/api/media/' + id)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Delete the media with @id
     * @param id
     */

    factory.deleteMedia = function (id) {
      var defer = $q.defer();

      $http.delete('/api/media/' + id)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    return factory;
  }
]);

/**
 * @file
 * Contains the screen factory.
 */

/**
 * Screen factory. Main entry point for screens and screen groups.
 */
angular.module('ikApp').factory('screenFactory', ['$http', '$q', 'searchFactory',
  function ($http, $q, searchFactory) {
    'use strict';

    var factory = {};
    var currentScreen = null;

    /**
     * Search via search_node.
     * @param search
     * @returns {*|Number}
     */
    factory.searchScreens = function (search) {
      search.type = 'Indholdskanalen\\MainBundle\\Entity\\Screen';
      return searchFactory.search(search);
    };

    /**
     * Get all screens.
     *
     * @returns {Array}
     */
    factory.getScreens = function () {
      var defer = $q.defer();

      $http.get('/api/screens')
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Load the screens with the given ids.
     *
     * @param ids
     */
    factory.loadScreensBulk = function loadScreensBulk(ids) {
      var defer = $q.defer();

      // Build query string.
      var queryString = "?";
      for (var i = 0; i < ids.length; i++) {
        queryString = queryString + "ids[]=" + ids[i];
        if (i < ids.length - 1) {
          queryString = queryString + "&"
        }
      }

      // Load bulk.
      $http.get('/api/screens/bulk' + queryString)
        .success(function (data, status) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status)
        });

      return defer.promise;
    };

    /**
     * Get the current screen.
     * @param id
     * @returns {promiseAndHandler.promise|*|Promise._progressUnchecked.promise|promise|exports.exports.Reduction.promise|PromiseResolver.promise}
     */
    factory.getEditScreen = function (id) {
      var defer = $q.defer();

      if (id === null || id === undefined || id === '') {
        defer.resolve(currentScreen);
      } else {
        $http.get('/api/screen/' + id)
          .success(function (data) {
            currentScreen = data;
            defer.resolve(currentScreen);
          })
          .error(function (data, status) {
            defer.reject(status);
          });
      }

      return defer.promise;
    };

    /**
     * Find the screen with @id
     * @param id
     * @returns screen or null
     */
    factory.getScreen = function (id) {
      var defer = $q.defer();

      $http.get('/api/screen/' + id)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Saves screen.
     */
    factory.saveScreen = function () {
      var defer = $q.defer();

      if (currentScreen === null) {
        defer.reject(404);
      } else {
        $http.post('/api/screen', currentScreen)
          .success(function (data) {
            currentScreen.id = data;
            defer.resolve(data);
          })
          .error(function (data, status) {
            defer.reject(status);
          });
      }

      return defer.promise;
    };

    /**
     * Returns an empty screen.
     * @returns screen (empty)
     */
    factory.emptyScreen = function () {
      currentScreen = {
        id: null,
        template: null,
        description: '',
        title: '',
        orientation: 'landscape',
        width: 1920,
        height: 1080,
        channel_screen_regions: [],
        options: {}
      };

      return currentScreen;
    };

    return factory;
  }
]);


/**
 * @file
 * Contains the search factory.
 */

/**
 * Search factory that handles communication with search engine.
 *
 * The communication is based on web-sockets via socket.io library.
 */
angular.module('ikApp').service('searchFactory', ['$q', '$rootScope', '$http', 'itkLog',
  function ($q, $rootScope, $http, itkLog) {
    'use strict';

    var socket;
    var token = null;

    /**
     * Connect to the web-socket.
     *
     * @param deferred
     *   The is a deferred object that should be resolved on connection.
     */
    function getSocket(deferred) {
      // Get connected to the server.
      socket = io.connect(window.config.search.address, {
        'query': 'token=' + token,
        'force new connection': true,
        'max reconnection attempts': Infinity
      });

      // Handle error events.
      socket.on('error', function (reason) {
        itkLog.error(reason, 'Search socket error.');
        deferred.reject(reason);
      });

      socket.on('connect', function () {
        deferred.resolve('Connected to the server.');
      });

      // Handle disconnect event (fires when disconnected or connection fails).
      socket.on('disconnect', function (reason) {
        // @todo: re-connection is automatically handled by socket.io library,
        // but we might need to stop sending request until reconnection or the
        // request will be queued and send all at once... which could give some
        // strange side effects in the application if not handled.
      });
    }

    /**
     * Create the connection to the server.
     *
     * @return {promise}
     *   An promise is return that will be resolved on connection.
     */
    function connect() {
      // Try to connect to the server if not already connected.
      var deferred = $q.defer();

      if (socket === undefined) {
        if (token !== null) {
          getSocket(deferred);
        }
        else {
          $http.get('api/auth/search')
            .success(function (data) {
              token = data.token;
              getSocket(deferred);
            })
            .error(function (data, status) {
              itkLog.error(data, 'Authentication (search) to search node failed (' + status + ')');
              deferred.reject(status);
            });
        }
      }
      else {
        deferred.resolve('Connected to the server.');
      }

      return deferred.promise;
    }

    /**
     * Send search request to the engine.
     *
     * The default search should have this form:
     *
     * {
     *   "fields": 'title',
     *     "text": '',
     *     "sort": [
     *      {
     *       "created_at.raw" : {
     *         "order": "desc"
     *       }
     *     }
     *     ],
     *     "filter": [ ]
     *   }
     * }
     *
     * @param search
     *   This is a json object as described above as default.
     *
     * @returns {promise}
     *   When data is received from the backend. If no data found an empty JSON
     *   object is returned.
     */
    this.search = function (search) {
      var deferred = $q.defer();

      // Build default match all search query.
      var query = {
        "index": window.config.search.index,
        "type": search.type,
        "query": {
          "match_all": {}
        }
      };

      // Text given build field search query.
      // The analyser ensures that we match the who text string sent not part
      // of. @TODO: It this the right behaviour.
      if (search.text !== undefined && search.text !== '') {
        query.query = {
          "multi_match": {
            "query": search.text,
            "fields": search.fields,
            "analyzer": 'string_search'
          }
        };
      }

      // Add sort
      query.sort = search.sort;

      // Add filter.
      // @TODO: move to the start.
      if (search.filter !== undefined) {
        query.query = {
          "filtered": {
            "query": query.query,
            "filter": search.filter
          }
        };
      }

      // Add pager to the query.
      if (search.hasOwnProperty('pager')) {
        query.size = search.pager.size;
        query.from = search.pager.page * search.pager.size;
      }

      connect().then(function () {
        socket.emit('search', query);
        socket.once('result', function (hits) {
          deferred.resolve(hits);
        });

        // Catch search errors.
        socket.once('searchError', function (error) {
          itkLog.error('Search error', error.message);
          deferred.reject(error.message);
        });
      });

      return deferred.promise;
    };
  }
]);

/**
 * @file
 * Contains the shared channel factory.
 */

/**
 * Shared Channel factory. Main entry point for accessing shared channels.
 */
angular.module('ikApp').factory('sharedChannelFactory', ['$http', '$q', 'sharedSearchFactory',
  function ($http, $q, sharedSearchFactory) {
    'use strict';

    var factory = {};

    var availableIndexes = null;

    /**
     * Search via share Factory.
     * @param search
     * @param indexName
     * @returns {*|Number}
     */
    factory.searchChannels = function (search, indexName) {
      search.type = 'Indholdskanalen\\MainBundle\\Entity\\Channel';
      return sharedSearchFactory.search(search, indexName);
    };

    /**
     * Get a shared channel.
     * @param id
     * @param index
     */
    factory.getSharedChannel = function getSharedChannel(id, index) {
      var defer = $q.defer();

      $http.get('/api/sharing/channel/' + id + '/' + index)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Save shared channel.
     * @param channel
     * @returns {*}
     */
    factory.saveSharedChannel = function saveSharedChannel(channel) {
      var defer = $q.defer();

      $http.post('/api/sharing/channel', channel)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Get available indexes from sharing service
     * @returns {*}
     */
    factory.getAvailableIndexes = function () {
      var defer = $q.defer();

      if (availableIndexes !== null) {
        defer.resolve(availableIndexes);
      }
      else {
        $http.get('/api/sharing/available_indexes')
          .success(function (data) {
            availableIndexes = data;
            defer.resolve(data);
          })
          .error(function (data, status) {
            defer.reject(status);
          });
      }

      return defer.promise;
    };

    /**
     * Save sharing indexes.
     * @param indexes
     * @returns {*}
     */
    factory.saveSharingIndexes = function (indexes) {
      var defer = $q.defer();

      $http.post('/api/sharing/indexes', indexes)
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Get the available sharing indexes.
     * @returns array of sharing indexes.
     */
    factory.getSharingIndexes = function () {
      var defer = $q.defer();

      $http.get('/api/sharing/indexes')
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    return factory;
  }
]);

/**
 * @file
 * Contains the search factory.
 */

/**
 * Shared search factory that handles communication with share search engine.
 *
 * The communication is based on web-sockets via socket.io library.
 */
angular.module('ikApp').service('sharedSearchFactory', ['$q', '$rootScope', '$http', 'itkLog',
  function ($q, $rootScope, $http, itkLog) {
    'use strict';

    var socket;
    var token = null;

    /**
     * Connect to the web-socket.
     */
    function getSocket(deferred) {
      // Get connected to the server.
      socket = io.connect(window.config.sharingService.address, {
        'query': 'token=' + token,
        'force new connection': true,
        'max reconnection attempts': Infinity
      });

      // Handle error events.
      socket.on('error', function (reason) {
        itkLog.error(reason, 'Search socket error.');
        deferred.reject(reason);
      });

      socket.on('connect', function () {
        deferred.resolve('Connected to the server.');
      });

      // Handle disconnect event (fires when disconnected or connection fails).
      socket.on('disconnect', function (reason) {
        // @todo: re-connection is automatically handled by socket.io library,
        // but we might need to stop sending request until reconnection or the
        // request will be queued and send all at once... which could give some
        // strange side effects in the application if not handled.
      });
    }

    /**
     * Create the connection to the server.
     *
     * @return {promise}
     *   An promise is return that will be resolved on connection.
     */
    function connect() {
      // Try to connect to the server if not already connected.
      var deferred = $q.defer();

      if (socket === undefined) {
        if (token !== null) {
          getSocket(deferred);
        }
        else {
          $http.get('api/auth/sharing')
            .success(function (data) {
              token = data.token;
              getSocket(deferred);
            })
            .error(function (data, status) {
              itkLog.error(data, 'Authentication (sharing) to search node failed (' + status + ')');
              deferred.reject(status);
            });
        }
      }
      else {
        deferred.resolve('Connected to the server.');
      }

      return deferred.promise;
    }

    /**
     * Send search request to the engine.
     *
     * The default search should have this form:
     *
     * {
     *   "fields": 'title',
     *     "text": '',
     *     "sort": [
     *      {
     *       "created_at.raw" : {
     *         "order": "desc"
     *       }
     *     }
     *     ],
     *     "filter": [ ]
     *   }
     * }
     *
     * @param search
     *   This is a json object as described above as default.
     *
     * @param index
     *   Which index to search in.
     *
     * @returns {promise}
     *   When data is received from the backend. If no data found an empty JSON
     *   object is returned.
     */
    this.search = function (search, index) {
      var deferred = $q.defer();

      // Build default match all search query.
      var query = {
        "index": index,
        "type": search.type,
        "query": {
          "match_all": {}
        }
      };

      // Text given build field search query.
      // The analyser ensures that we match the who text string sent not part
      // of. @TODO: It this the right behaviour.
      if (search.text !== undefined && search.text !== '') {
        query.query = {
          "multi_match": {
            "query": search.text,
            "fields": search.fields,
            "analyzer": 'string_search'
          }
        };
      }

      // Add sort
      query.sort = search.sort;

      // Add filter.
      // @TODO: move to the start.
      if (search.filter !== undefined) {
        query.query = {
          "filtered": {
            "query": query.query,
            "filter": search.filter
          }
        };
      }

      // Add pager to the query.
      if (search.hasOwnProperty('pager')) {
        query.size = search.pager.size;
        query.from = search.pager.page * search.pager.size;
      }

      connect().then(function () {
        socket.emit('search', query);
        socket.once('result', function (hits) {
          deferred.resolve(hits);
        });

        // Catch search errors.
        socket.once('searchError', function (error) {
          itkLog.error('Search error', error.message);
          deferred.reject(error.message);
        });
      });

      return deferred.promise;
    };
  }
]);

/**
 * @file
 * Contains the slide factory.
 */

/**
 * Slide factory. Main entry point for slides.
 */
angular.module('ikApp').factory('slideFactory', ['$http', '$q', 'searchFactory',
  function ($http, $q, searchFactory) {
    'use strict';

    var factory = {};

    // Currently open slide.
    // This is the slide we are editing.
    var currentSlide = null;

    /**
     * Search via search_node.
     * @param search
     * @returns {*|Number}
     */
    factory.searchSlides = function (search) {
      search.type = 'Indholdskanalen\\MainBundle\\Entity\\Slide';
      return searchFactory.search(search);
    };

    /**
     * Get all slides.
     */
    factory.getSlides = function getSlides() {
      var defer = $q.defer();

      $http.get('/api/slides')
        .success(function (data, status) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Load the slides with the given ids.
     *
     * @param ids
     */
    factory.loadSlidesBulk = function loadSlidesBulk(ids) {
      var defer = $q.defer();

      // Build query string.
      var queryString = "?";
      for (var i = 0; i < ids.length; i++) {
        queryString = queryString + "ids[]=" + ids[i];
        if (i < ids.length - 1) {
          queryString = queryString + "&"
        }
      }

      // Load bulk.
      $http.get('/api/slides/bulk' + queryString)
        .success(function (data, status) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status)
        });

      return defer.promise;
    };

    /**
     * Clear currently slide.
     */
    factory.clearCurrentSlide = function clearCurrentSlide() {
      currentSlide = null;
    };

    /**
     * Find slide to edit. If id is not set return current slide, else load from backend.
     * @param id
     */
    factory.getEditSlide = function getEditSlide(id) {
      var defer = $q.defer();

      if (id === null || id === undefined || id === '') {
        defer.resolve(currentSlide);
      }
      else {
        if (currentSlide !== null && currentSlide.id == id) {
          defer.resolve(currentSlide);
        }
        else {
          $http.get('/api/slide/' + id)
            .success(function (data, status) {
              currentSlide = data;
              defer.resolve(currentSlide);
            })
            .error(function (data, status) {
              defer.reject(status);
            });
        }
      }

      return defer.promise;
    };

    /**
     * Find the slide with @id
     * @param id
     */
    factory.getSlide = function (id) {
      var defer = $q.defer();

      $http.get('/api/slide/' + id)
        .success(function (data, status) {
          defer.resolve(data);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Saves slide to slides.
     */
    factory.saveSlide = function () {
      var defer = $q.defer();

      $http.post('/api/slide', currentSlide)
        .success(function (data) {
          defer.resolve(data);
          currentSlide = null;
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Returns an empty slide.
     * @returns slide (empty)
     */
    factory.emptySlide = function () {
      currentSlide = {
        "id": null,
        "published": true,
        "schedule_from": null,
        "schedule_to": null,
        "media": [],
        "media_type": null,
        "title": '',
        "user": '',
        "duration": '',
        "orientation": '',
        "template": '',
        "options": null
      };

      return currentSlide;
    };

    return factory;
  }
]);


/**
 * @file
 * Contains the template factory.
 */

/**
 * Template factory. Main entry point for templates.
 */
angular.module('ikApp').factory('templateFactory', ['$q', '$http',
  function ($q, $http) {
    'use strict';

    var factory = {};
    var slideTemplates = null;
    var screenTemplates = null;

    /**
     * Gets slide templates from cache or symfony.
     *
     * @returns {templates|*}
     */
    factory.getSlideTemplates = function () {
      var defer = $q.defer();

      if (slideTemplates !== null) {
        defer.resolve(slideTemplates);
      }
      else {
        $http.get('/api/templates/slides/enabled')
          .success(function (data) {
            slideTemplates = data;
            defer.resolve(slideTemplates);
          })
          .error(function (data, status) {
            defer.reject(status);
          });
      }

      return defer.promise;
    };

    /**
     * Get slide template with id from cache or symfony.
     *
     * @param id
     * @returns {*}
     */
    factory.getSlideTemplate = function (id) {
      var defer = $q.defer();

      factory.getSlideTemplates().then(
        function (data) {
          for (var i = 0; i < data.length; i++) {
            if (data[i].id === id) {
              defer.resolve(data[i]);
              return;
            }
          }
          defer.reject(404);
        },
        function (reason) {
          defer.reject(reason);
        }
      );

      return defer.promise;
    };

    /**
     * Gets screen templates from cache or symfony.
     *
     * @returns {templates|*}
     */
    factory.getScreenTemplates = function () {
      var defer = $q.defer();

      if (screenTemplates !== null) {
        defer.resolve(screenTemplates);
      }
      else {
        $http.get('/api/templates/screens/enabled')
          .success(function (data) {
            screenTemplates = data;
            defer.resolve(screenTemplates);
          })
          .error(function (data, status) {
            defer.reject(status);
          });
      }

      return defer.promise;
    };

    /**
     * Get screen template with id from cache or symfony.
     *
     * @param id
     * @returns {*}
     */
    factory.getScreenTemplate = function (id) {
      var defer = $q.defer();

      factory.getScreenTemplates().then(
        function (data) {
          for (var i = 0; i < data.length; i++) {
            if (data[i].id === id) {
              defer.resolve(data[i]);
              return;
            }
          }
          defer.reject(404);
        },
        function (reason) {
          defer.reject(reason);
        }
      );

      return defer.promise;
    };

    /**
     * Save which templates are enabled.
     *
     * @param enabledScreenTemplates
     * @param enabledSlideTemplates
     */
    factory.saveEnabledTemplates = function (enabledScreenTemplates, enabledSlideTemplates) {
      var defer = $q.defer();

      $http.post('/api/templates/save/enabled', {
        "screens": enabledScreenTemplates,
        "slides": enabledSlideTemplates
      })
        .success(function (data, status) {
          $http.get('/api/templates/slides/enabled')
            .success(function (data) {
              slideTemplates = data;
            })
            .error(function (data, status) {
              // @TODO: Handle this.
            });
          $http.get('/api/templates/screen/enabled')
            .success(function (data) {
              screenTemplates = data;
            })
            .error(function (data, status) {
              // @TODO: Handle this.
            });

          defer.resolve(status);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Get all slide templates.
     * @returns {*}
     */
    factory.getAllSlideTemplates = function () {
      var defer = $q.defer();

      $http.get('/api/templates/slides/all')
        .success(function (data) {
          slideTemplates = data;
          defer.resolve(slideTemplates);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    /**
     * Get all screen templates.
     * @returns {*}
     */
    factory.getAllScreenTemplates = function () {
      var defer = $q.defer();

      $http.get('/api/templates/screens/all')
        .success(function (data) {
          slideTemplates = data;
          defer.resolve(slideTemplates);
        })
        .error(function (data, status) {
          defer.reject(status);
        });

      return defer.promise;
    };

    return factory;
  }
]);
/**
 * @file
 * Contains the user factory.
 */

/**
 * User factory.
 */
angular.module('ikApp').factory('userFactory', ['$http', '$q',
  function ($http, $q) {
    'use strict';

    var factory = {};

    /**
     * Get current user.
     */
    factory.getCurrentUser = function () {
      var defer = $q.defer();

      $http.get('/api/user')
        .success(function (data) {
          defer.resolve(data);
        })
        .error(function () {
          defer.reject();
        });

      return defer.promise;
    };

    return factory;
  }
]);

/**
 * @file
 * Contains the itkDateComponent module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module('itkDateComponent', []);

  /**
   * date component directive.
   *
   * html parameters:
   */
  app.directive('dateComponent', ['$interval',
    function ($interval) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/components/date/date.html?' + window.config.version,
        scope: {
          theme: '@'
        },
        link: function (scope) {
          scope.thisDate = new Date();

          // Update current date every minute.
          var interval = $interval(function() {
            // Update current datetime.
            scope.thisDate = new Date();
          }, 60000);

          // Register event listener for destroy.
          //   Cleanup interval.
          scope.$on('$destroy', function() {
            if (angular.isDefined(interval)) {
              $interval.cancel(interval);
              interval = undefined;
            }
          });
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the itkDateComponent module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module('itkDigitalClockComponent', []);

  /**
   * date component directive.
   *
   * html parameters:
   */
  app.directive('digitalClockComponent', ['$interval',
    function ($interval) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/components/digital-clock/digital-clock.html?' + window.config.version,
        scope: {
        },
        link: function (scope) {
          scope.thisDate = new Date();

          // Update current date every minute.
          var interval = $interval(function() {
            // Update current datetime.
            scope.thisDate = Date.now();
          }, 1000);

          // Register event listener for destroy.
          //   Cleanup interval.
          scope.$on('$destroy', function() {
            if (angular.isDefined(interval)) {
              $interval.cancel(interval);
              interval = undefined;
            }
          });
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Add delete button
 */

/**
 * Channel preview directive. Displays the channel preview.
 * Has a play button.
 * When pressing the channel, but not the play button, redirect to the channel editor.
 */
angular.module('ikApp').directive('ikActionReloadScreen', ['$http', 'itkLog',
  function ($http, itkLog) {
    'use strict';

    return {
      restrict: 'E',
      replace: false,
      scope: {
        id: '@'
      },
      link: function (scope) {
        scope.reloadScreen = function () {
          var result = window.confirm('Er du sikker på at du vil genindlæse skærmen?');
          if (result === true) {
            $http.post('/api/screen/' + scope.id + '/reload')
              .success(function () {
                itkLog.info('Genindlæsning lykkedes.');
              })
              .error(function (reason) {
                itkLog.error('Genindlæsning lykkedes ikke!', reason);
              });
          }
        };
      },
      templateUrl: 'app/shared/elements/actionReloadScreen/action-reload-screen.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Add delete button
 */

/**
 * Channel preview directive. Displays the channel preview.
 * Has a play button.
 * When pressing the channel, but not the play button, redirect to the channel editor.
 */
angular.module('ikApp').directive('ikActionsMenu', [
  function () {
    'use strict';

    return {
      restrict: 'E',
      replace: false,
      transclude: true,
      scope: {
      },
      link: function (scope) {
        scope.menuOpen = false;

        scope.toggleMenu = function toggleMenu() {
          scope.menuOpen = !scope.menuOpen;
        }
      },
      templateUrl: 'app/shared/elements/actionsMenu/actions-menu.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the auto-grow directive.
 */

/**
 * HTML attribute for textareas. Makes the textarea grow.
 * Uses jQuery.
 */
angular.module('ikApp').directive('autoGrow', function() {
  'use strict';

  return {
    restrict: 'A',
    scope: {
      fontSize: '@'
    },
    link: function(scope, element) {
      var el = $(element);

      var resizeTextArea = function resizeTextArea(el) {
        el.css('height', '0px');
        var sh = el.prop('scrollHeight');
        var minh = el.css('min-height').replace('px', '');
        el.css('height', Math.max(sh, minh) + 'px');
      };

      element.bind('keyup', function() {
        resizeTextArea(el);
      });

      scope.$watch('fontSize', function(val) {
        if (val) {
          resizeTextArea(el);
        }
      });

      setTimeout(function() {
        resizeTextArea(el);
      }, 100);
    }
  };
});
/**
 * @file
 * Contains channel directives.
 */

/**
 * Channel preview directive. Displays the channel preview.
 * Has a play button.
 * When pressing the channel, but not the play button, redirect to the channel editor.
 */
angular.module('ikApp').directive('ikChannel', ['$interval', '$location',
  function($interval, $location) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikWidth: '@',
        ikChannel: '=',
        ikSingleSlide: '=',
        ikClickable: '='
      },
      link: function(scope, element, attrs) {
        scope.slideIndex = 0;
        scope.playText = '';

        // Observe on changes to ik-slide, for when it is set.
        attrs.$observe('ikChannel', function(val) {
          if (!val) {
            return;
          }

          // If channel is empty, display empty channel.
          if (scope.ikChannel.slides.length <= 0) {
            scope.templateURL = 'app/shared/elements/channel/empty.html?' + window.config.version;
          }
          else {
            scope.templateURL = 'app/shared/elements/channel/non-empty.html?' + window.config.version;

            scope.buttonState = 'play';
          }
        });

        /**
         * Start playing the slides.
         */
        scope.play = function() {
          if (angular.isDefined(scope.interval)) {
            $interval.cancel(scope.interval);
            scope.interval = undefined;
            scope.buttonState = 'play';
          } else {
            scope.slideIndex = (scope.slideIndex + 1) % scope.ikChannel.slides.length;

            scope.interval = $interval(function() {
              scope.slideIndex = (scope.slideIndex + 1) % scope.ikChannel.slides.length;
            }, 2000);
            scope.buttonState = 'pause';
          }
        };

        /**
         * Redirect to the channel editor page.
         */
        scope.redirectToChannel = function() {
          if (scope.ikClickable) {
            $location.path('/channel/' + scope.ikChannel.id);
          }
        };

        // Register event listener for destroy.
        //   Cleanup interval.
        scope.$on('$destroy', function() {
          if (angular.isDefined(scope.interval)) {
            $interval.cancel(scope.interval);
            scope.interval = undefined;
          }
        });
      },
      templateUrl: 'app/shared/elements/channel/channel-template.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the channel overview controller.
 */

/**
 * Directive to show the Channel overview.
 */
angular.module('ikApp').directive('ikChannelOverview', ['channelFactory', 'userFactory', 'itkLog',
  function(channelFactory, userFactory, itkLog) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikSelectedChannels: '=',
        ikOverlay: '@'
      },
      link: function(scope) {
        scope.displaySharingOption = window.config.sharingService.enabled;
        scope.loading = false;

        scope.showFromUser = 'all';
        scope.sort = { "created_at": "desc" };

        userFactory.getCurrentUser().then(
          function(data) {
            scope.currentUser = data;
          }
        );

        // Default pager values.
        scope.pager = {
          "size": 6,
          "page": 0
        };
        scope.hits = 0;

        // Channels to display.
        scope.channels = [];

        // Setup default search options.
        var search = {
          "fields": 'title',
          "text": '',
          "filter": {
            "bool": {
              "must": []
            }
          },
          "sort": {
            "created_at" : {
              "order": 'desc'
            }
          },
          'pager': scope.pager
        };

        /**
         * Updates the channels array by send a search request.
         */
        scope.updateSearch = function updateSearch() {
          // Get search text from scope.
          search.text = scope.search_text;

          scope.loading = true;

          channelFactory.searchChannels(search).then(
            function success(data) {
              // Total hits.
              scope.hits = data.hits;

              // Extract search ids.
              var ids = [];
              for (var i = 0; i < data.results.length; i++) {
                ids.push(data.results[i].id);
              }

              // Load slides bulk.
              channelFactory.loadChannelsBulk(ids).then(
                function success(data) {
                  scope.channels = data;

                  scope.loading = false;
                },
                function error(reason) {
                  itkLog.error("Kunne ikke loade søgeresultatet.", reason);
                  scope.loading = false;
                }
              );
            }
          );
        };

        /**
         * Update search result on channel deletion.
         */
        scope.$on('channel-deleted', function() {
          scope.updateSearch();
        });

        /**
         * Returns true if channel is in selected channels array.
         *
         * @param channel
         * @returns {boolean}
         */
        scope.channelSelected = function channelSelected(channel) {
          if (!scope.ikSelectedChannels) {
            return false;
          }

          var res = false;

          scope.ikSelectedChannels.forEach(function(element) {
            if (element.id === channel.id) {
              res = true;
            }
          });

          return res;
        };

        /**
         * Emits the slideOverview.clickSlide event.
         *
         * @param channel
         */
        scope.channelOverviewClickChannel = function channelOverviewClickChannel(channel) {
          scope.$emit('channelOverview.clickChannel', channel);
        };

        /**
         * Changes if all slides are shown or only slides belonging to current user
         *
         * @param user
         *   This should either be 'mine' or 'all'.
         */
        scope.setUser = function setUser(user) {
          if (scope.showFromUser !== user) {
            scope.showFromUser = user;

            scope.setSearchFilters();
          }
        };

        /**
         * Updates the search filter based on current orientation and user
         */
        scope.setSearchFilters = function setSearchFilters() {
          // Update orientation for the search.
          delete search.filter;

          if(scope.showFromUser !== 'all') {
            search.filter = {
              "bool": {
                "must": []
              }
            };
          }

          var term = {};

          if (scope.showFromUser !== 'all') {
            term.term = {user : scope.currentUser.id};
            search.filter.bool.must.push(term);
          }

          scope.updateSearch();
        };

        /**
         * Changes the sort order and updated the channels.
         *
         * @param sortField
         *   Field to sort on.
         * @param sortOrder
         *   The order to sort in 'desc' or 'asc'.
         */
        scope.setSort = function setSort(sortField, sortOrder) {
          // Only update search if sort have changed.
          if (scope.sort[sortField] === undefined || scope.sort[sortField] !== sortOrder) {
            // Update the store sort order.
            scope.sort = { };
            scope.sort[sortField] = sortOrder;

            // Update the search variable.
            search.sort = { };
            search.sort[sortField] = {
              "order": sortOrder
            };

            scope.updateSearch();
          }
        };

        scope.updateSearch();
      },
      templateUrl: '/app/shared/elements/channelOverview/channel-overview-directive.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains channel share directives.
 */

/**
 * channel-share directive.
 *
 * Enables sharing a channel.
 *
 * html-parameters
 *   ikChannel (object): Channel to share.
 */
angular.module('ikApp').directive('ikChannelShare', [
  function () {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikChannel: '='
      },
      link: function (scope) {
        scope.clickShare = function () {
          scope.$emit('ikChannelShare.clickShare', scope.ikChannel);
        };
      },
      templateUrl: 'app/shared/elements/channelShare/channel-share.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the checklist directive
 */

/**
 * Checklist directive.
 *
 */
angular.module('ikApp').directive('ikChecklist', [
  function () {
    'use strict';

    return {
      restrict: 'E',
      replace: false,
      scope: {
        elements: '=',
        selected: '=',
        identity: '='
      },
      link: function (scope) {
        scope.toggleElement = function toggleElement(el) {
          if (!scope.selected) {
            return;
          }

          var index = -1;

          scope.selected.forEach(function (element, ind) {
            if (element[scope.identity] === el[scope.identity]) {
              index = ind;
            }
          });

          if (index > -1) {
            scope.selected.splice(index, 1);
          }
          else {
            scope.selected.push(el);
          }
        };

        scope.elementSelected = function elementSelected(el) {
          if (!scope.selected) {
            return false;
          }

          for (var i = 0; i < scope.selected.length; i++) {
            if (scope.selected[i][scope.identity] === el[scope.identity]) {
              return true;
            }
          }

          return false;
        };
      },
      templateUrl: 'app/shared/elements/checklist/checklist.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the itkControlPanel module.
 */

/**
 * Setup the module.
 */
(function() {
  'use strict';

  var app;
  app = angular.module('itkControlPanel', []);

  /**
   * control-panel directive.
   *
   * html parameters:
   *   template (string): The control panel template to render.
   *   data (object): The data object to manipulate in the control panel.
   *   display (boolean): Should the control panel be visible?
   *   saveAction (function): The function to call on a saveAction.
   *   region (integer): The region (id) to manipulate.
   */
  app.directive('controlPanel',
    function() {
      return {
        restrict: 'E',
        scope: {
          template: '=',
          data: '=',
          display: '=',
          saveAction: '&',
          region: '=',
          options: '='
        },
        replace: true,
        link: function(scope) {
          // Which control panel tab is selected?
          scope.selectedTab = null;

          // Lock scrolling on page.
          $('html').addClass('is-locked');

          /**
           * Get the template for the control panel.
           * @returns string
           *   Path to the template.
           */
          scope.getContent = function getContent() {
            return scope.template;
          };

          /**
           * Click a tab.
           * @param tab
           *   Name of the tab to display and which nav to show active.
           */
          scope.clickTab = function clickNav(tab) {
            scope.selectedTab = tab;
          };

          /**
           * Click a channel type.
           * @param type
           *   Name of the channel type to display and which channel type to show active.
           */
          scope.toggleChannelType = function toggleChannelType(type) {
            scope.channelType = type;
          };

          // Register event listener for destroy.
          // Remove scroll lock.
          scope.$on('$destroy', function() {
            document.getElementsByTagName('body')[0].style.overflow = '';
          });
        },
        template: '<div data-ng-include="getContent()"></div>'
      };
    }
  );
}).call(this);

/**
 * @file
 * Add delete button
 */

/**
 * Channel preview directive. Displays the channel preview.
 * Has a play button.
 * When pressing the channel, but not the play button, redirect to the channel editor.
 */
angular.module('ikApp').directive('ikDelete', ['$http', '$rootScope', 'itkLog',
  function ($http, $rootScope, itkLog) {
    'use strict';

    return {
      restrict: 'E',
      replace: false,
      scope: {
        id: '@',
        type: '@'
      },
      link: function (scope) {
        // Handle clicks on numbers.
        scope.remove = function () {
          var result = window.confirm('Er du sikker på du vil slette dette? Handlingen kan ikke fortrydes.');
          if (result === true) {
            $http.delete('/api/' + scope.type + '/' + scope.id)
              .success(function () {
                itkLog.info('Sletning lykkedes.');
                $rootScope.$broadcast(scope.type + '-deleted', {});
              })
              .error(function (reason) {
                itkLog.error('Sletning lykkes ikke!', reason);
              });
          }
        };
      },
      templateUrl: 'app/shared/elements/delete/delete.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the include-replace directive.
 */

/**
 * HTML attribute to replace the ng-include div.
 */
angular.module('ikApp').directive('includeReplace', function () {
  'use strict';

  return {
    require: 'ngInclude',
    restrict: 'A',
    link: function (scope, el) {
      el.replaceWith(el.children());
    }
  };
});

/**
 * @file
 * Contains the media overview directive.
 */

/**
 * Media Overview Directive.
 *
 * Directive to insert a media overview.
 *
 * Emits the mediaOverview.selectMedia event when a media from the overview has been clicked.
 *
 * @param media-type
 *   which media type should be shown, "image" or "video",
 *   leave out show all media.
 */
angular.module('ikApp').directive('ikMediaOverview', ['itkLog',
  function (itkLog) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikMediaType: '@',
        ikAutoSearch: '@',
        ikHideFilters: '=',
        ikSelectedMedia: '='
      },
      controller: ["$scope", "mediaFactory", "userFactory", function ($scope, mediaFactory, userFactory) {
        // Set default orientation and sort.
        $scope.sort = {"created_at": "desc"};
        $scope.showFromUser = 'all';
        $scope.loading = false;

        userFactory.getCurrentUser().then(
          function (data) {
            $scope.currentUser = data;
          }
        );

        // Set default search text.
        $scope.search_text = '';

        // Set default media type.
        $scope.media_type = 'all';

        // Media to display.
        $scope.media = [];

        // Default pager values.
        $scope.pager = {
          "size": 6,
          "page": 0
        };
        $scope.hits = 0;

        // Setup default search options.
        var search = {
          "fields": 'name',
          "text": '',
          "sort": {
            "created_at": {
              "order": "desc"
            }
          },
          'pager': $scope.pager
        };

        /**
         * Updates the images array by sending a search request.
         */
        $scope.updateSearch = function updateSearch() {
          // Get search text from scope.
          search.text = $scope.search_text;

          $scope.loading = true;

          mediaFactory.searchMedia(search).then(
            function (data) {
              // Total hits.
              $scope.hits = data.hits;

              // Extract search ids.
              var ids = [];
              for (var i = 0; i < data.results.length; i++) {
                ids.push(data.results[i].id);
              }

              mediaFactory.loadMediaBulk(ids).then(
                function success(data) {
                  $scope.media = data;

                  $scope.loading = false;
                },
                function error(reason) {
                  itkLog.error("Hentning af søgeresultater fejlede.", reason);
                  $scope.loading = false;
                }
              );
            }
          );
        };

        /**
         * Returns true if media is in selected media array.
         *
         * @param media
         * @returns {boolean}
         */
        $scope.mediaSelected = function mediaSelected(media) {
          if (!$scope.ikSelectedMedia) {
            return false;
          }

          var res = false;

          $scope.ikSelectedMedia.forEach(function (element) {
            if (element.id === media.id) {
              res = true;
            }
          });

          return res;
        };

        /**
         * Set the media type to filter on.
         * @param type
         */
        $scope.filterMediaType = function filterMediaType(type) {
          // Only update search if value changes.
          if ($scope.media_type !== type) {
            // Update scope to show selection in GUI.
            $scope.media_type = type;

            $scope.setSearchFilters();
          }
        };

        /**
         * Updates the search filter based on current orientation and user
         */
        $scope.setSearchFilters = function setSearchFilters() {
          // Update orientation for the search.
          delete search.filter;

          if ($scope.media_type !== 'all' || $scope.showFromUser !== 'all') {
            search.filter = {
              "bool": {
                "must": []
              }
            }
          }

          if ($scope.media_type !== 'all') {
            var term = {};
            term.term = {
              media_type: $scope.media_type
            };
            search.filter.bool.must.push(term);
          }

          if ($scope.showFromUser !== 'all') {
            var term = {};
            term.term = {
              user: $scope.currentUser.id
            };
            search.filter.bool.must.push(term);
          }

          $scope.updateSearch();
        };

        /**
         * Changes if all slides are shown or only slides belonging to current user
         *
         * @param user
         *   This should either be 'mine' or 'all'.
         */
        $scope.setUser = function setUser(user) {
          if ($scope.showFromUser !== user) {
            $scope.showFromUser = user;

            $scope.setSearchFilters();
            $scope.updateSearch();
          }
        };

        /**
         * Changes the sort order and updated the images.
         *
         * @param sort_field
         *   Field to sort on.
         * @param sort_order
         *   The order to sort in 'desc' or 'asc'.
         */
        $scope.setSort = function setSort(sort_field, sort_order) {
          // Only update search if sort have changed.
          if ($scope.sort[sort_field] === undefined || $scope.sort[sort_field] !== sort_order) {
            // Update the store sort order.
            $scope.sort = {};
            $scope.sort[sort_field] = sort_order;

            // Update the search variable.
            search.sort = {};
            search.sort[sort_field] = {
              "order": sort_order
            };

            $scope.updateSearch();
          }
        };

        /**
         * Emits event when the user clicks a media.
         *
         * @param mediaElement
         */
        $scope.mediaOverviewClickMedia = function mediaOverviewClickImage(mediaElement) {
          $scope.$emit('mediaOverview.selectMedia', mediaElement);
        };

        /**
         * Handle mediaOverview.updateSearch events.
         */
        $scope.$on('mediaOverview.updateSearch', function (event) {
          $scope.updateSearch();

          event.preventDefault();
        });
      }],
      link: function (scope, element, attrs) {
        attrs.$observe('ikMediaType', function (val) {
          if (!val) {
            return;
          }
          if (val == scope.media_type) {
            return;
          }

          scope.filterMediaType(val);
        });

        attrs.$observe('ikAutoSearch', function (val) {
          // Send the default search query.
          if (scope.ikAutoSearch === "true") {
            scope.updateSearch();
          }
        })
      },
      templateUrl: '/app/shared/elements/mediaOverview/media-overview-directive.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains directives for media upload.
 */

/**
 * Media Upload Directive.
 *
 * Emits the mediaUpload.uploadSuccess event when upload i successful.
 *
 * Emits the 'mediaUpload.uploadComplete' event for a parent controller to catch.
 *   Catch this event to handle when the upload is complete.
 */
angular.module('ikApp').directive('ikMediaUpload', [
  function () {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikUploadType: '@'
      },
      controller: ["$scope", "FileUploader", function ($scope, FileUploader) {
        $scope.currentStep = 1;
        $scope.uploadComplete = false;
        $scope.uploadErrors = false;
        $scope.uploadInProgress = false;
        $scope.uploadErrorText = '';

        var acceptedVideotypes = '|mp4|x-msvideo|x-ms-wmv|quicktime|mpeg|mpg|x-matroska|ogg|webm';
        var acceptedImagetypes = '|jpg|png|jpeg|bmp|gif';

        // Set accepted media types.
        var acceptedMediatypes = '';
        if ($scope.ikUploadType === 'image' || $scope.ikUploadType === 'logo') {
          acceptedMediatypes = acceptedImagetypes;
        } else if ($scope.ikUploadType === 'video') {
          acceptedMediatypes = acceptedVideotypes;
        } else {
          acceptedMediatypes = acceptedVideotypes + acceptedImagetypes;
        }

        // Create an uploader
        $scope.uploader = new FileUploader({
          url: '/api/media',
          queueLimit: 1,
          filters: [{
            name: 'mediaFilter',
            fn: function (item /*{File|FileLikeObject}*/) {
              var type = '|' + item.type.slice(item.type.lastIndexOf('/') + 1);
              return acceptedMediatypes.indexOf(type) !== -1;
            }
          }]
        });

        /**
         * Calls the hidden select files button.
         */
        $scope.selectFiles = function () {
          angular.element(document.querySelector('#select-files')).click();
        };

        /**
         * Clear the uploader queue.
         */
        $scope.clearQueue = function () {
          $scope.uploader.clearQueue();
          $scope.uploadComplete = false;
          $scope.uploadErrors = false;
          $scope.currentStep = 1;
          $scope.uploadErrorText = '';
        };

        /**
         * Remove item from the uploader queue.
         * @param item
         */
        $scope.removeItem = function (item) {
          item.remove();
          if ($scope.uploader.queue.length <= 0) {
            $scope.currentStep = 1;
            $scope.uploadComplete = false;
            $scope.uploadErrors = false;
          }
        };

        $scope.upload = function upload() {
          $scope.uploadInProgress = true;
          $scope.uploader.uploadAll();
        };

        /**
         * Checks whether the item is an image.
         */
        $scope.isImage = function (item) {
          var type = '|' + item.type.slice(item.type.lastIndexOf('/') + 1);
          return acceptedImagetypes.indexOf(type) !== -1;
        };

        /**
         * Returns the uploader progress.
         * NB! THIS IS A HACK!
         *
         * @returns {*}
         */
        $scope.getProgress = function () {
          if (!$scope.uploader.progress) {
            return;
          }

          if ($scope.uploadInProgress && $scope.uploader.progress > 5) {
            return $scope.uploader.progress - 5;
          } else {
            return $scope.uploader.progress;
          }
        };

        /**
         * After adding a file to the upload queue, add an empty title to the file item.
         */
        $scope.uploader.onAfterAddingFile = function (item) {
          item.formData = [
            {
              "title": "",
              "logo": false
            }
          ];

          if ($scope.ikUploadType === 'logo') {
            item.formData[0].logo = true;
          }
        };

        /**
         * After adding all files, increase current step.
         */
        $scope.uploader.onAfterAddingAll = function () {
          $scope.currentStep++;
        };

        /**
         * If an error occurs.
         * @param item
         * @param response
         * @param status
         */
        $scope.uploader.onErrorItem = function (item, response, status) {
          $scope.uploadErrors = true;
          $scope.uploadInProgress = false;

          if (status === 413) {
            $scope.uploadErrorText = "Filen var for stor (fejlkode: 413)";
          } else {
            $scope.uploadErrorText = "Der skete en fejl (fejlkode: " + status + ")";
          }
        };

        /**
         * When all uploads are complete.
         */
        $scope.uploader.onCompleteAll = function () {
          $scope.uploadComplete = true;
          $scope.uploadInProgress = false;
        };

        /**
         * When an item has been uploaded successfully.
         * @param item
         * @param response
         */
        $scope.uploader.onSuccessItem = function (item, response) {
          $scope.$emit('mediaUpload.uploadSuccess', {
            image: item,
            id: response[0],
            queue: $scope.uploader.queue
          });
        };
      }],
      link: function () {
      },
      templateUrl: '/app/shared/elements/mediaUpload/media-upload-directive.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the ngModel module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;

  app = angular.module('ngModal', []);

  /**
   * modal-dialog directive.
   *
   * This is a modified version of: https://github.com/adamalbrecht/ngModal
   *
   * html parameters:
   *   show (boolean): should the modal be visible?
   *   onClose (function): function to call on close action.
   */
  app.directive('modalDialog', [
    function () {
      return {
        restrict: 'E',
        scope: {
          show: '=',
          onClose: '&?'
        },
        replace: true,
        transclude: true,
        link: function (scope) {
          scope.hideModal = function () {
            scope.show = false;
          };
          scope.$watch('show', function (newVal, oldVal) {
            if (newVal && !oldVal) {
              document.getElementsByTagName('body')[0].style.overflow = 'hidden';
            } else {
              document.getElementsByTagName('body')[0].style.overflow = '';
            }
            if ((!newVal && oldVal) && (scope.onClose !== null)) {
              return scope.onClose();
            }
          });
        },
        templateUrl: 'app/shared/elements/ngModal/ng-modal.html?' + window.config.version
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Paging directive.
 */

/**
 * Paging directive.
 */
angular.module('ikApp').directive('ikPager', [
  function () {
    'use strict';

    return {
      restrict: 'E',
      replace: true,
      scope: true,
      controller: ["$scope", function ($scope) {
        $scope.pagesFrom = 0;
        $scope.pagesPerLine = 4;

        /**
         * Click handler to change page.
         *
         * @param page
         */
        $scope.changePage = function changePage(page) {
          $scope.pager.page = page;
          $scope.updateSearch();

          $scope.pagesFrom = Math.floor($scope.pager.page / $scope.pagesPerLine) * $scope.pagesPerLine;
        };

        $scope.prevPage = function prevPage() {
          if ($scope.pager.page > 0) {
            $scope.pager.page--;
            $scope.updateSearch();
          }

          if ($scope.pager.page < $scope.pagesFrom) {
            $scope.pagesFrom = $scope.pagesFrom - $scope.pagesPerLine;
          }
        };

        $scope.nextPage = function nextPage() {
          if ($scope.pager.page < $scope.pager.max - 1) {
            $scope.pager.page++;
            $scope.updateSearch();
          }

          if ($scope.pager.page === $scope.pagesFrom + $scope.pagesPerLine) {
            $scope.pagesFrom = $scope.pagesFrom + $scope.pagesPerLine;
          }
        };

        $scope.prevLine = function firstPage() {
          if ($scope.pager.page > 0) {
            $scope.pager.page = $scope.pager.page - $scope.pagesPerLine;
            if ($scope.pager.page < 0) {
              $scope.pager.page = 0;
            }
            $scope.updateSearch();
          }

          $scope.pagesFrom = Math.floor($scope.pager.page / $scope.pagesPerLine) * $scope.pagesPerLine;
        };

        $scope.nextLine = function lastPage() {
          if ($scope.pager.page < $scope.pager.max - 1) {
            $scope.pager.page = $scope.pager.page + $scope.pagesPerLine;
            if ($scope.pager.page >= $scope.pager.max) {
              $scope.pager.page = $scope.pager.max - 1;
            }
            $scope.updateSearch();
          }

          $scope.pagesFrom = Math.floor($scope.pager.page / $scope.pagesPerLine) * $scope.pagesPerLine;
        };

        // Keep an any on changes in number of hits.
        $scope.$watch('hits', function (hits) {
            var pages = [];
            $scope.pager.max = 0;
            if (hits > $scope.pager.size) {
              $scope.pager.max = Math.ceil(hits / $scope.pager.size);
              for (var i = 0; i < $scope.pager.max; i++) {
                pages.push(i);
              }
            }
            $scope.pager.pages = pages;
          }
        );
      }],
      templateUrl: '/app/shared/elements/pager/pager-directive.html?' + window.config.version
    };
  }
]);


/**
 * @file
 * Contains screen directives.
 */

/**
 * Directive to insert a screen.
 */
angular.module('ikApp').directive('ikScreen', [
  function () {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikScreen: '='
      },
      link: function (scope, element, attrs) {
        // Observe for changes to the ikScreen attribute.
        attrs.$observe('ikScreen', function (val) {
          if (!val) {
            return;
          }

          // Set the style of the screen.
          if (scope.ikScreen.template.orientation === 'landscape') {
            scope.style = {
              "width": "300px",
              "height": "168.5px"
            };
          }
          else {
            scope.style = {
              "height": "300px",
              "width": "168.5px"
            };
          }
        });
      },
      templateUrl: 'app/shared/elements/screen/screen-template.html?' + window.config.version
    };
  }
]);


/**
 * @file
 * Contains channel directives.
 */

/**
 * Shared channel preview directive. Displays the channel preview.
 * Has a play button.
 * When pressing the channel, but not the play button, redirect to the channel editor.
 */
angular.module('ikApp').directive('ikSharedChannel', ['$interval', '$location', 'cssInjector',
  function($interval, $location, cssInjector) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikWidth: '@',
        ikChannel: '=',
        ikSingleSlide: '@',
        ikSharingIndex: '=',
        ikClickable: '='
      },
      link: function(scope) {
        scope.slideIndex = 0;
        scope.playText = '';

        // Observe on changes to ik-slide, for when it is set.
        scope.$watch('ikChannel', function (val) {
          if (!val) {
            return;
          }

          // If channel is empty, display empty channel.
          if (scope.ikChannel.slides.length <= 0) {
            scope.templateURL = 'app/shared/elements/sharedChannel/empty-channel.html?' + window.config.version;
          }
          else {
            scope.templateURL = 'app/shared/elements/sharedChannel/non-empty-channel.html?' + window.config.version;

            scope.buttonState = 'play';
          }

          // Injector stylesheets
          scope.ikChannel.slides.forEach(function (el) {
            // Inject stylesheet.
            cssInjector.add(el.css_path);
          });
        });

        /**
         * Start playing the slides.
         */
        scope.play = function play() {
          if (angular.isDefined(scope.interval)) {
            $interval.cancel(scope.interval);
            scope.interval = undefined;
            scope.buttonState = 'play';
          } else {
            scope.slideIndex = (scope.slideIndex + 1) % scope.ikChannel.slides.length;

            scope.interval = $interval(function() {
              scope.slideIndex = (scope.slideIndex + 1) % scope.ikChannel.slides.length;
            }, 2000);
            scope.buttonState = 'pause';
          }
        };

        /**
         * Redirect to the channel editor page.
         */
        scope.redirectToChannel = function redirectToChannel() {
          if (scope.ikClickable) {
            $location.path("/shared-channel/" + scope.ikChannel.unique_id + "/" + scope.ikSharingIndex);
          }
        };

        // Register event listener for destroy.
        //   Cleanup interval.
        scope.$on('$destroy', function () {
          if (angular.isDefined(scope.interval)) {
            $interval.cancel(scope.interval);
            scope.interval = undefined;
          }
        });
      },
      templateUrl: 'app/shared/elements/sharedChannel/shared-channel-template.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the channel sharing overview controller.
 */

/**
 * Directive to show the Channel Sharing overview.
 */
angular.module('ikApp').directive('sharedChannelOverview', ['sharedChannelFactory', 'userFactory', '$timeout', 'itkLog',
  function(sharedChannelFactory, userFactory, $timeout, itkLog) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikSelectedChannels: '=',
        ikOverlay: '@',
        ikSingleSlide: '='
      },
      link: function(scope) {
        scope.index = {};
        scope.loading = false;
        scope.pickIndexDialog = false;

        scope.displaySharingOption = window.config.sharingService.enabled;
        scope.sharingIndexes = [];
        sharedChannelFactory.getSharingIndexes().then(function(data) {
          scope.sharingIndexes = data;
        });

        scope.showFromUser = 'all';
        scope.sort = { "created_at": "desc" };

        userFactory.getCurrentUser().then(
          function success(data) {
            scope.currentUser = data;
          },
          function error(reason) {
            itkLog.error("Kunne ikke loade bruger", reason);
          }
        );

        // Default pager values.
        scope.pager = {
          "size": 6,
          "page": 0
        };
        scope.hits = 0;

        // Channels to display.
        scope.channels = [];

        // Setup default search options.
        var search = {
          "fields": 'title',
          "text": '',
          "filter": {
            "bool": {
              "must": {
              }
            }
          },
          "sort": {
            "created_at" : {
              "order": "desc"
            }
          },
          'pager': scope.pager
        };

        /**
         * Updates the channels array by send a search request.
         */
        scope.updateSearch = function updateSearch() {
          // Get search text from scope.
          search.text = scope.search_text;

          if (angular.isUndefined(scope.index.index)) {
            itkLog.info("Du skal vælge et indeks først", 3000);
            return;
          }

          scope.loading = true;
          sharedChannelFactory.searchChannels(search, scope.index.index).then(
            function success(data) {
              scope.loading = false;
              scope.hits = data.hits;
              scope.channels = data.results;
            },
            function error(reason) {
              scope.loading = false;

              itkLog.error("Hentning af søgeresultater fejlede.", reason);
            }
          );
        };

        /**
         * Update search result on channel deletion.
         */
        scope.$on('channel-deleted', function() {
          scope.updateSearch();
        });

        /**
         * Returns true if channel is in selected channels array.
         *
         * @param channel
         * @returns {boolean}
         */
        scope.channelSelected = function channelSelected(channel) {
          if (!scope.ikSelectedChannels) {
            return false;
          }

          var res = false;

          scope.ikSelectedChannels.forEach(function(element) {
            if (element.unique_id == channel.unique_id) {
              res = true;
            }
          });

          return res;
        };

        /**
         * Emits the channelSharingOverview.clickChannel event.
         *
         * @param channel
         * @param index
         */
        scope.clickSharedChannel = function clickSharedChannel(channel, index) {
          scope.$emit('channelSharingOverview.clickSharedChannel', channel, index);
        };

        /**
         * Change which index is selected.
         * @param index
         */
        scope.setIndex = function setIndex(index) {
          scope.index = index;
          scope.pickIndexDialog = false;

          scope.updateSearch();
        };

        /**
         * Changes if all slides are shown or only slides belonging to current user
         *
         * @param user
         *   This should either be 'mine' or 'all'.
         */
        scope.setUser = function setUser(user) {
          if (scope.showFromUser !== user) {
            scope.showFromUser = user;

            scope.updateSearch();
          }
        };

        /**
         * Updates the search filter based on current orientation and user
         */
        scope.setSearchFilters = function setSearchFilters() {
          // Update orientation for the search.
          delete search.filter;

          if(scope.showFromUser !== 'all') {
            search.filter = {
              "bool": {
                "must": []
              }
            }
          }

          if (scope.showFromUser !== 'all') {
            var term = {};
            term.term = {user : scope.currentUser.id};
            search.filter.bool.must.push(term);
          }

          scope.updateSearch();
        };

        /**
         * Changes the sort order and updated the channels.
         *
         * @param sort_field
         *   Field to sort on.
         * @param sort_order
         *   The order to sort in 'desc' or 'asc'.
         */
        scope.setSort = function setSort(sort_field, sort_order) {
          // Only update search if sort have changed.
          if (scope.sort[sort_field] === undefined || scope.sort[sort_field] !== sort_order) {
            // Update the store sort order.
            scope.sort = { };
            scope.sort[sort_field] = sort_order;

            // Update the search variable.
            search.sort = { };
            search.sort[sort_field] = {
              "order": sort_order
            };

            scope.updateSearch();
          }
        };
      },
      templateUrl: '/app/shared/elements/sharedChannelOverview/shared-channel-overview.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the ik-shared-slide directive.
 */

/**
 * Directive to insert html for a slide.
 * @param ik-id: the id of the slide.
 * @param ik-width: the width of the slide.
 */
angular.module('ikApp').directive('ikSharedSlide', ['cssInjector',
  function (cssInjector) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikWidth: '@',
        ikSlide: '='
      },
      link: function (scope, element, attrs) {
        scope.templateURL = '/app/shared/elements/slide/slide-loading.html?' + window.config.version;

        // Observe for changes to the ik-slide attribute. Setup slide when ik-slide is set.
        attrs.$observe('ikSlide', function (val) {
          if (!val) {
            return;
          }

          cssInjector.add(scope.ikSlide.css_path);

          if (scope.ikSlide.media_thumbs && scope.ikSlide.media_thumbs.length > 0) {
            scope.ikSlide.currentImage = scope.ikSlide.media_thumbs[0];
          }

          scope.ikSlide.currentLogo = scope.ikSlide.logo;

          scope.templateURL = scope.ikSlide.preview_path;

          scope.theStyle = {
            width: "" + scope.ikWidth + "px",
            height: "" + parseFloat(1080.0 * parseFloat(scope.ikWidth / 1920.0)) + "px"
          };

          if (scope.ikSlide.options.fontsize) {
            scope.theStyle.fontsize = "" + parseFloat(scope.ikSlide.options.fontsize * parseFloat(scope.ikWidth / 1920)) + "px"
          }
        });
      },
      template: '<div class="preview--slide" data-ng-include="" src="templateURL"></div>'
    }
  }
]);


/**
 * @file
 * Contains slide directives to display and edit a slide.
 */

/**
 * Directive to insert html for a slide.
 * @param ik-id: the id of the slide.
 * @param ik-width: the width of the slide.
 */
angular.module('ikApp').directive('ikSlide', ['slideFactory', 'templateFactory', 'itkLog',
  function (slideFactory, templateFactory, itkLog) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikWidth: '@',
        ikSlide: '='
      },
      link: function (scope, element, attrs) {
        scope.templateURL = '/app/shared/elements/slide/slide-loading.html?' + window.config.version;

        // Observe for changes to the ik-slide attribute. Setup slide when ik-slide is set.
        attrs.$observe('ikSlide', function (val) {
          if (!val) {
            return;
          }

          if (scope.ikSlide.media_type === 'image') {
            if (scope.ikSlide.media.length > 0) {
              scope.ikSlide.currentImage = scope.ikSlide.media[0].urls.default_landscape_small;
            }
            else {
              scope.ikSlide.currentImage = '';
            }
          }
          else {
            if (scope.ikSlide.media.length > 0 && scope.ikSlide.media[0].provider_metadata.length > 0) {
              scope.ikSlide.currentImage = scope.ikSlide.media[0].provider_metadata[0].thumbnails[1].reference;
            }
            else {
              scope.ikSlide.currentImage = '';
            }
          }

          // Set the currentLogo variable.
          if (scope.ikSlide.logo !== undefined && scope.ikSlide.logo !== null) {
            scope.ikSlide.currentLogo = scope.ikSlide.logo.urls.default_landscape;
          }
          else {
            scope.ikSlide.currentLogo = '';
          }

          // Get the template.
          templateFactory.getSlideTemplate(scope.ikSlide.template).then(
            function success(data) {
              scope.template = data;
              scope.templateURL = scope.template.paths.preview;

              scope.theStyle = {
                width: "" + scope.ikWidth + "px",
                height: "" + parseFloat(scope.template.ideal_dimensions.height * parseFloat(scope.ikWidth / scope.template.ideal_dimensions.width)) + "px"
              };

              if (scope.ikSlide.options.fontsize) {
                scope.theStyle.fontsize = "" + parseFloat(scope.ikSlide.options.fontsize * parseFloat(scope.ikWidth / scope.template.ideal_dimensions.width)) + "px"
              }
            },
            function error(reason) {
              itkLog.error("Hentning af templates fejlede.", reason);
            }
          );
        });
      },
      template: '<div class="preview--slide" data-ng-style="{\'width\': theStyle.width}" data-ng-include="" src="templateURL"></div>'
    }
  }
]);

/**
 * @file
 * Contains the directive for an editable slide.
 */

/**
 * Directive to insert html for a slide, that is editable.
 * @param ik-slide: the slide.
 * @param ik-width: the width of the slide.
 */
angular.module('ikApp').directive('ikSlideEditable', ['templateFactory', 'itkLog',
  function (templateFactory, itkLog) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikWidth: '@',
        ikSlide: '='
      },
      link: function (scope, element, attrs) {
        scope.templateURL = '/app/shared/elements/slide/slide-loading.html?' + window.config.version;

        // Watch for changes to ikSlide.
        scope.$watch('ikSlide', function (newVal, oldVal) {
          if (!newVal) {
            return;
          }

          if (scope.ikSlide.media_type === 'image') {
            if (scope.ikSlide.media.length > 0) {
              scope.ikSlide.currentImage = scope.ikSlide.media[0].urls.default_landscape;
            }
            else {
              scope.ikSlide.currentImage = '';
            }
          }
          else if (scope.ikSlide.media_type === 'video') {
            if (scope.ikSlide.media.length > 0) {
              if (scope.ikSlide.media[0] === undefined) {
                scope.ikSlide.currentVideo = {"mp4": "", "ogg": "", "webm": ""};
              }
              else {
                if (scope.ikSlide.media.length > 0 && scope.ikSlide.media[0].provider_metadata.length > 0) {
                  // Set current video variable to path to video files.
                  scope.ikSlide.currentVideo = {};
                  if (scope.ikSlide.media[0].provider_metadata[0]) {
                    scope.ikSlide.currentVideo.mp4 = scope.ikSlide.media[0].provider_metadata[0].reference;
                  }
                  if (scope.ikSlide.media[0].provider_metadata[1]) {
                    scope.ikSlide.currentVideo.ogg = scope.ikSlide.media[0].provider_metadata[1].reference;
                  }
                  if (scope.ikSlide.media[0].provider_metadata[2]) {
                    scope.ikSlide.currentVideo.webm = scope.ikSlide.media[0].provider_metadata[2].reference;
                  }
                }

                // Reload video player.
                setTimeout(function () {
                  element.find('#videoPlayer').load();
                }, 1000);
              }
            }
            else {
              scope.ikSlide.currentVideo = {"mp4": "", "ogg": "", "webm": ""};
            }
          }

          // Set the currentLogo variable.
          if (scope.ikSlide.logo !== undefined && scope.ikSlide.logo !== null) {
            scope.ikSlide.currentLogo = scope.ikSlide.logo.urls.default_landscape;
          }
          else {
            scope.ikSlide.currentLogo = '';
          }

          if (!scope.template || newVal.template !== oldVal.template) {
            templateFactory.getSlideTemplate(scope.ikSlide.template).then(
              function success(data) {
                scope.template = data;
                scope.templateURL = scope.template.paths.edit;

                // Setup the inline styling
                scope.theStyle = {
                  width: "" + scope.ikWidth + "px",
                  height: "" + parseFloat(scope.template.ideal_dimensions.height * parseFloat(scope.ikWidth / scope.template.ideal_dimensions.width)) + "px",
                  fontsize: "" + parseFloat(scope.ikSlide.options.fontsize * parseFloat(scope.ikWidth / scope.template.ideal_dimensions.width)) + "px"
                };
              },
              function error(reason) {
                itkLog.error("Hentning af template fejlede.", reason);
              }
            );
          }

          if (scope.theStyle) {
            // Update fontsize
            scope.theStyle.fontsize = "" + parseFloat(scope.ikSlide.options.fontsize * parseFloat(scope.ikWidth / scope.template.ideal_dimensions.width)) + "px";
          }
        }, true);
      },
      templateUrl: '/app/shared/elements/slide/slide-edit.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the slide overview directive.
 */

/**
 * Directive to show the slide overview.
 */
angular.module('ikApp').directive('ikSlideOverview', ['itkLog',
  function (itkLog) {
    'use strict';

    return {
      restrict: 'E',
      scope: {
        ikSelectedSlides: '=',
        ikOverlay: '@'
      },
      controller: ["$scope", "slideFactory", "userFactory", function ($scope, slideFactory, userFactory) {
        $scope.loading = false;

        $scope.showFromUser = 'all';
        $scope.sort = {"created_at": "desc"};

        userFactory.getCurrentUser().then(
          function (data) {
            $scope.currentUser = data;
          }
        );

        // Default pager values.
        $scope.pager = {
          "size": 6,
          "page": 0
        };
        $scope.hits = 0;

        // Slides to display.
        $scope.slides = [];

        // Setup default search options.
        var search = {
          "fields": ['title'],
          "text": $scope.search_text,
          "sort": {
            "created_at": {
              "order": "desc"
            }
          },
          'pager': $scope.pager
        };

        /**
         * Updates the slides array by send a search request.
         */
        $scope.updateSearch = function updateSearch() {
          // Get search text from scope.
          search.text = $scope.search_text;

          $scope.loading = true;

          slideFactory.searchSlides(search).then(
            function (data) {
              // Total hits.
              $scope.hits = data.hits;

              // Extract search ids.
              var ids = [];
              for (var i = 0; i < data.results.length; i++) {
                ids.push(data.results[i].id);
              }

              // Load slides bulk.
              slideFactory.loadSlidesBulk(ids).then(
                function success(data) {
                  $scope.slides = data;

                  $scope.loading = false;
                },
                function error(reason) {
                  $scope.loading = false;

                  itkLog.error("Hentning af søgeresultater fejlede.", reason);
                }
              );
            }
          );
        };

        /**
         * Update search result on slide deletion.
         */
        $scope.$on('slide-deleted', function (data) {
          $scope.updateSearch();
        });

        /**
         * Changes if all slides are shown or only slides belonging to current user
         *
         * @param user
         *   This should either be 'mine' or 'all'.
         */
        $scope.setUser = function setUser(user) {
          if ($scope.showFromUser !== user) {
            $scope.showFromUser = user;

            $scope.setSearchFilters();
            $scope.updateSearch();
          }
        };

        /**
         * Updates the search filter based on current orientation and user
         */
        $scope.setSearchFilters = function setSearchFilters() {
          // Update orientation for the search.
          delete search.filter;

          if ($scope.showFromUser !== 'all') {
            search.filter = {
              "bool": {
                "must": []
              }
            }
          }

          if ($scope.showFromUser !== 'all') {
            var term = {};
            term.term = {user: $scope.currentUser.id};
            search.filter.bool.must.push(term);
          }

          $scope.updateSearch();
        };

        /**
         * Returns true if slide is in selected slides array.
         *
         * @param slide
         * @returns {boolean}
         */
        $scope.slideSelected = function slideSelected(slide) {
          if (!$scope.ikSelectedSlides) {
            return false;
          }

          var res = false;

          $scope.ikSelectedSlides.forEach(function (element, index) {
            if (element.id == slide.id) {
              res = true;
            }
          });

          return res;
        };

        /**
         * Calculates if a scheduling is set and whether we are currently showing it or not.
         *
         * @param slide
         *   The current slide.
         *
         * @return
         *   True if the slide has a schedule set, and we are outside the scope of the schedule.
         */
        $scope.outOfSchedule = function outOfSchedule(slide) {
          if (slide.schedule_from && slide.schedule_to) { // From and to time is set.
            if (slide.schedule_from * 1000 < Date.now() && slide.schedule_to * 1000 > Date.now()) {
              // Current time is between from and to time (ie inside schedule).
              return false;
            }
            // Current time is set but is outside from and to time (ie out of schedule).
            return true;
          }
          // No schedule is set.
          return false;
        };

        /**
         * Changes the sort order and updated the slides.
         *
         * @param sort_field
         *   Field to sort on.
         * @param sort_order
         *   The order to sort in 'desc' or 'asc'.
         */
        $scope.setSort = function setSort(sort_field, sort_order) {
          // Only update search if sort have changed.
          if ($scope.sort[sort_field] === undefined || $scope.sort[sort_field] !== sort_order) {
            // Update the store sort order.
            $scope.sort = {};
            $scope.sort[sort_field] = sort_order;

            // Update the search variable.
            search.sort = {};
            search.sort[sort_field] = {
              "order": sort_order
            };

            $scope.updateSearch();
          }
        };

        /**
         * Emits the slideOverview.clickSlide event.
         *
         * @param slide
         */
        $scope.slideOverviewClickSlide = function slideOverviewClickSlide(slide) {
          $scope.$emit('slideOverview.clickSlide', slide);
        };

        // Send the default search query.
        $scope.updateSearch();
      }],
      templateUrl: '/app/shared/elements/slideOverview/slide-overview-directive.html?' + window.config.version
    };
  }
]);

/**
 * @file
 * Contains the ik-thumb directive.
 */

/**
 * The ik-thumb directive
 * NB! Has been renamed to ik-thumb
 * @author: nerv
 * @version: 0.1.2, 2014-01-09
 */
angular.module('ikApp').directive('ikThumb', ['$window', function ($window) {
  'use strict';

  var helper = {
    support: !!($window.FileReader && $window.CanvasRenderingContext2D),
    isFile: function (item) {
      return angular.isObject(item) && item instanceof $window.File;
    },
    isImage: function (file) {
      var type = '|' + file.type.slice(file.type.lastIndexOf('/') + 1);
      return '|jpg|png|jpeg|bmp|gif|'.indexOf(type) !== -1;
    }
  };

  return {
    restrict: 'A',
    template: '<canvas/>',
    link: function (scope, element, attributes) {
      if (!helper.support) return;

      var params = scope.$eval(attributes.ikThumb);

      if (!helper.isFile(params.file)) {
        return;
      }
      if (!helper.isImage(params.file)) {
        return;
      }

      var canvas = element.find('canvas');

      var reader = new FileReader();

      reader.onload = onLoadFile;
      reader.readAsDataURL(params.file);

      function onLoadFile(event) {
        var img = new Image();
        img.onload = onLoadImage;
        img.src = event.target.result;
      }

      function onLoadImage() {
        var width = params.width ? params.width : this.width / this.height * params.height;
        var height = params.height ? params.height : this.height / this.width * params.width;
        canvas.attr({width: width, height: height});
        canvas[0].getContext('2d').drawImage(this, 0, 0, width, height);
      }
    }
  };
}]);

/**
 * @file
 * Contains the itkChannelPickerWidget module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkChannelPickerWidget", []);

  /**
   * channel-picker-widget directive.
   *
   * html parameters:
   *   screen (object): The screen to modify.
   *   region (integer): The region of the screen to modify.
   */
  app.directive('channelPickerWidget', ['userFactory', 'channelFactory', 'itkLog',
    function (userFactory, channelFactory, itkLog) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/widgets/channelPickerWidget/channel-picker-widget.html?' + window.config.version,
        scope: {
          screen: '=',
          region: '='
        },
        link: function (scope) {
          scope.sharingEnabled = window.config.sharingService.enabled;
          scope.loading = false;

          scope.showFromUser = 'all';
          scope.sort = {"created_at": "desc"};

          userFactory.getCurrentUser().then(
            function success(data) {
              scope.currentUser = data;
            },
            function error(reason) {
              itkLog.error("Kunne ikke hente bruger", reason);
            }
          );

          // Default pager values.
          scope.pager = {
            "size": 5,
            "page": 0
          };
          scope.hits = 0;

          // Channels to display.
          scope.channels = [];

          // Setup default search options.
          var search = {
            "fields": 'title',
            "text": '',
            "filter": {
              "bool": {
                "must": []
              }
            },
            "sort": {
              "created_at": {
                "order": "desc"
              }
            },
            'pager': scope.pager
          };

          /**
           * Updates the channels array by send a search request.
           */
          scope.updateSearch = function updateSearch() {
            // Get search text from scope.
            search.text = scope.search_text;

            scope.loading = true;

            channelFactory.searchChannels(search).then(
              function (data) {
                // Total hits.
                scope.hits = data.hits;

                // Extract search ids.
                var ids = [];
                for (var i = 0; i < data.results.length; i++) {
                  ids.push(data.results[i].id);
                }

                // Load slides bulk.
                channelFactory.loadChannelsBulk(ids).then(
                  function success(data) {
                    scope.channels = data;

                    scope.loading = false;
                  },
                  function error(reason) {
                    itkLog.error("Kunne ikke hente søgeresultater", reason);
                    scope.loading = false;
                  }
                );
              }
            );
          };

          /**
           * Returns true if channel is in channel array with region.
           *
           * @param channel
           * @returns {boolean}
           */
          scope.channelSelected = function channelSelected(channel) {
            var element;
            for (var i = 0; i < scope.screen.channel_screen_regions.length; i++) {
              element = scope.screen.channel_screen_regions[i];
              if (element.channel && element.channel.id === channel.id && element.region === scope.region) {
                return true;
              }
            }
            return false;
          };

          /**
           * Adding a channel to screen region.
           * @param channel
           *   Channel to add to the screen region.
           */
          scope.addChannel = function addChannel(channel) {
            scope.screen.channel_screen_regions.push({
              "id": null,
              "screen_id": scope.screen.id,
              "channel": channel,
              "region": scope.region
            });
          };

          /**
           * Removing a channel from a screen region.
           * @param channel
           *   Channel to remove from the screen region.
           */
          scope.removeChannel = function removeChannel(channel) {
            var element;
            for (var i = 0; i < scope.screen.channel_screen_regions.length; i++) {
              element = scope.screen.channel_screen_regions[i];
              if (element.channel && element.channel.id === channel.id && element.region === scope.region) {
                scope.screen.channel_screen_regions.splice(i, 1);
              }
            }
          };

          /**
           * When the screen is loaded, set search orientation.
           */
          scope.$watch('screen', function (val) {
            if (!val) return;

            // Update the search.
            scope.updateSearch();
          });
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the itkChannelRemoveWidget module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkChannelRemoverWidget", []);

  /**
   * channel-remover-widget directive.
   *
   * html parameters:
   *   screen (object): the screen to modify.
   *   region (integer): the region of the screen to modify.
   */
  app.directive('channelRemoverWidget', [
    function () {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/widgets/channelRemoverWidget/channel-remover-widget.html?' + window.config.version,
        scope: {
          screen: '=',
          region: '='
        },
        link: function (scope) {
          scope.search_text = '';

          /**
           * Get the search object for the filter.
           * @returns {{title: string}}
           */
          scope.getSearch = function getSearch() {
            return {
              "title": scope.search_text
            };
          };

          /**
           * Removing a channel from a screen region.
           * @param channel
           *   Channel to remove from the screen region.
           */
          scope.removeChannel = function removeChannel(channel) {
            var element;
            for (var i = 0; i < scope.screen.channel_screen_regions.length; i++) {
              element = scope.screen.channel_screen_regions[i];
              if (element.shared_channel === undefined && element.channel.id === channel.id && element.region === scope.region) {
                scope.screen.channel_screen_regions.splice(i, 1);
              }
              else if (element.shared_channel && element.shared_channel.unique_id === channel.unique_id && element.region === scope.region) {
                scope.screen.channel_screen_regions.splice(i, 1);
              }
            }
          };
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the itkNumberWidget module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkNumberWidget", []);

  /**
   * number-widget directive.
   *
   * html parameters:
   *   field: The field to modify.
   *   placeholderText (string): The placeholder text to display.
   */
  app.directive('numberWidget',
    function () {
      return {
        restrict: 'E',
        scope: {
          field: '=',
          placeholderText: '@'
        },
        replace: true,
        template: '<input type="number" class="cpw--text-input" placeholder="{{placeholderText}}" data-ng-model="field">'
      };
    }
  );
}).call(this);

/**
 * @file
 * Contains the itkRegionPreviewWidget module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkRegionPreviewWidget", []);

  /**
   * region-preview-widget directive.
   *
   * html paramters:
   *   region (integer): The region to modify.
   *   screen (object): The screen to modify.
   */
  app.directive('regionPreviewWidget', [
    function () {
      return {
        restrict: 'E',
        scope: {
          region: '=',
          screen: '=',
          width: '='
        },
        replace: false,
        templateUrl: 'app/shared/widgets/regionPreviewWidget/region-preview-widget.html?' + window.config.version,
        link: function (scope) {
          scope.getNumberOfChannels = function getNumberOfChannels() {
            var n = 0;

            for (var i = 0; i < scope.screen.channel_screen_regions.length; i++) {
              if (scope.screen.channel_screen_regions[i].region === scope.region) {
                n++
              }
            }

            return n;
          };
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the itkScreenTemplatePickerWidget module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkScreenTemplatePickerWidget", []);

  /**
   * screen-template-picker-widget directive.
   *
   * html-parameters:
   *   screen (object): the screen to modify.
   */
  app.directive('screenTemplatePickerWidget', ['templateFactory', 'itkLog',
    function (templateFactory, itkLog) {
      return {
        restrict: 'E',
        scope: {
          screen: '='
        },
        replace: true,
        link: function (scope) {
          scope.templates = [];
          templateFactory.getScreenTemplates().then(
            function success(data) {
              scope.templates = data;
            },
            function error(reason) {
              itkLog.error("Kunne ikke loade templates", reason);
            }
          );

          /**
           * Set the template for the screen.
           * @param template
           *   The template.
           */
          scope.pickTemplate = function pickTemplate(template) {
            scope.screen.template = angular.copy(template);
          };
        },
        templateUrl: 'app/shared/widgets/screenTemplatePickerWidget/screenTemplatePickerWidget.html?' + window.config.version
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the itkSharedChannelPickerWidget module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkSharedChannelPickerWidget", []);

  /**
   * shared-channel-picker-widget directive.
   *
   * html parameters:
   *   screen (object): The screen to modify.
   *   region (integer): The region of the screen to modify.
   */
  app.directive('sharedChannelPickerWidget', ['sharedChannelFactory', 'itkLog',
    function (sharedChannelFactory, itkLog) {
      return {
        restrict: 'E',
        replace: true,
        templateUrl: 'app/shared/widgets/sharedChannelPickerWidget/shared-channel-picker-widget.html?' + window.config.version,
        scope: {
          screen: '=',
          region: '='
        },
        link: function (scope, element, attrs) {
          scope.index = null;
          scope.loading = false;
          scope.pickIndexDialog = false;

          scope.sharingIndexes = [];
          sharedChannelFactory.getSharingIndexes().then(
            function success(data) {
              scope.sharingIndexes = data;
            },
            function error(reason) {
              itkLog.error("Kunne ikke hente delingsindeks", reason);
            }
          );

          scope.showFromUser = 'all';
          scope.sort = {"created_at": "desc"};

          // Default pager values.
          scope.pager = {
            "size": 9,
            "page": 0
          };
          scope.hits = 0;

          // Channels to display.
          scope.channels = [];

          // Setup default search options.
          var search = {
            "fields": 'title',
            "text": '',
            "filter": {
              "bool": {
                "must": []
              }
            },
            "sort": {
              "created_at": {
                "order": "desc"
              }
            },
            'pager': scope.pager
          };

          /**
           * Updates the channels array by send a search request.
           */
          scope.updateSearch = function updateSearch() {
            if (scope.index === null) {
              return;
            }

            // Get search text from scope.
            search.text = scope.search_text;

            scope.loading = true;
            sharedChannelFactory.searchChannels(search, scope.index.index).then(
              function success(data) {
                scope.loading = false;
                scope.hits = data.hits;
                scope.channels = data.results;
              },
              function error(reason) {
                itkLog.error("Kunne ikke hente søgeresultater", reason);
                scope.loading = false;
              }
            );
          };

          /**
           * Change which index is selected.
           * @param index
           */
          scope.setIndex = function setIndex(index) {
            scope.index = index;
            scope.pickIndexDialog = false;

            scope.updateSearch();
          };

          /**
           * Returns true if channel is in channel array with region.
           *
           * @param channel
           * @returns {boolean}
           */
          scope.channelSelected = function channelSelected(channel) {
            var element;
            for (var i = 0; i < scope.screen.channel_screen_regions.length; i++) {
              element = scope.screen.channel_screen_regions[i];
              if (element.shared_channel && element.shared_channel.unique_id === channel.unique_id && element.region === scope.region) {
                return true;
              }
            }
            return false;
          };

          /**
           * Adding a channel to screen region.
           * @param channel
           *   Channel to add to the screen region.
           */
          scope.addChannel = function addChannel(channel) {
            if (channel.index === undefined || channel.index === null) {
              channel.index = scope.index.index;
            }

            scope.screen.channel_screen_regions.push({
              "id": null,
              "screen_id": scope.screen.id,
              "shared_channel": channel,
              "region": scope.region
            });
          };

          /**
           * Removing a channel from a screen region.
           * @param channel
           *   Channel to remove from the screen region.
           */
          scope.removeChannel = function removeChannel(channel) {
            var element;
            for (var i = 0; i < scope.screen.channel_screen_regions.length; i++) {
              element = scope.screen.channel_screen_regions[i];
              if (element.shared_channel && element.shared_channel.unique_id === channel.unique_id && element.region === scope.region) {
                scope.screen.channel_screen_regions.splice(i, 1);
              }
            }
          };

          /**
           * When the screen is loaded, set search orientation.
           */
          attrs.$observe('screen', function (val) {
            if (!val) return;

            // Update the search.
            scope.updateSearch();
          });
        }
      };
    }
  ]);
}).call(this);

/**
 * @file
 * Contains the itkTextAreaWidget module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkTextAreaWidget", []);

  /**
   * text-area-widget directive.
   *
   * html paramters:
   *   field: The field to modify.
   *   placeholderText (string): The placeholder text to display.
   */
  app.directive('textAreaWidget',
    function () {
      return {
        restrict: 'E',
        scope: {
          field: '=',
          placeholderText: '@'
        },
        replace: true,
        template: '<textarea class="cpw--textarea-input" data-ng-model="field" placeholder="{{placeholderText}}"></textarea>'
      };
    }
  );
}).call(this);

/**
 * @file
 * Contains the itkTextWidget module.
 */

/**
 * Setup the module.
 */
(function () {
  'use strict';

  var app;
  app = angular.module("itkTextWidget", []);

  /**
   * text-widget directive.
   *
   * html paramters:
   *   field: The field to modify.
   *   placeholderText (string): The placeholder text to display.
   */
  app.directive('textWidget',
    function () {
      return {
        restrict: 'E',
        scope: {
          field: '=',
          placeholderText: '@'
        },
        replace: true,
        template: '<input type="text" class="cpw--text-input" placeholder="{{placeholderText}}" data-ng-model="field">'
      };
    }
  );
}).call(this);
